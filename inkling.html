


<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Inkling Documentation - Bonsai</title>
    <style>
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight, .highlight .w {
  color: #f8f8f2;
  background-color: #272822;
}
.highlight .err {
  color: #272822;
  background-color: #f92672;
}
.highlight .c, .highlight .cd, .highlight .cm, .highlight .c1, .highlight .cs {
  color: #75715e;
}
.highlight .cp {
  color: #f4bf75;
}
.highlight .nt {
  color: #f4bf75;
}
.highlight .o, .highlight .ow {
  color: #f8f8f2;
}
.highlight .p, .highlight .pi {
  color: #f8f8f2;
}
.highlight .gi {
  color: #a6e22e;
}
.highlight .gd {
  color: #f92672;
}
.highlight .gh {
  color: #66d9ef;
  background-color: #272822;
  font-weight: bold;
}
.highlight .k, .highlight .kn, .highlight .kp, .highlight .kr, .highlight .kv {
  color: #ae81ff;
}
.highlight .kc {
  color: #fd971f;
}
.highlight .kt {
  color: #fd971f;
}
.highlight .kd {
  color: #fd971f;
}
.highlight .s, .highlight .sb, .highlight .sc, .highlight .sd, .highlight .s2, .highlight .sh, .highlight .sx, .highlight .s1 {
  color: #a6e22e;
}
.highlight .sr {
  color: #a1efe4;
}
.highlight .si {
  color: #cc6633;
}
.highlight .se {
  color: #cc6633;
}
.highlight .nn {
  color: #f4bf75;
}
.highlight .nc {
  color: #f4bf75;
}
.highlight .no {
  color: #f4bf75;
}
.highlight .na {
  color: #66d9ef;
}
.highlight .m, .highlight .mf, .highlight .mh, .highlight .mi, .highlight .il, .highlight .mo, .highlight .mb, .highlight .mx {
  color: #a6e22e;
}
.highlight .ss {
  color: #a6e22e;
}
    </style>
    <link href="stylesheets/screen.css" rel="stylesheet" media="screen" />
    <link href="stylesheets/print.css" rel="stylesheet" media="print" />
	<link href="stylesheets/test.css" rel="stylesheet" media="screen" />
    <link href="favicon.ico" rel="icon" type="image/ico" />
      <script src="javascripts/all.js"></script>
	
	<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-WVB6MG2');</script>
<!-- End Google Tag Manager -->
	
  </head>

  <body class="inkling" data-languages="[]">
	  
	  
	  <!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WVB6MG2"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) --> 

  <div id="flex-container">

	<section id="primary-nav" class="navigation">
  <div class="nav-container">
    <div class="brand">
     <a href="."><img class="bonsai-logo" src="https://dl.dropboxusercontent.com/s/d37ndmizplio8mw/bonsai-logo-color-docs.svg?dl=0"></a>
    </div>
    <nav>
      <div class="nav-mobile"><a id="nav-toggle" href="#!"><span></span></a></div>
      <ul class="nav-list">
        
		<li class="header_menu_item "> <a href="getting-started.html">Getting Started</a></li>
		
		<li class="header_menu_item selected">    <a href="inkling.html">Inkling</a>  </li>
		
		<li class="header_menu_item ">    <a href="reference.html">References</a>  </li>
      
        
       
		<li><gcse:search></gcse:search></li>

      </ul>
    </nav>
  </div>
</section>


	<div id="main-wrapper">

    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" alt="Navbar" />
      </span>
    </a>
    <div class="tocify-wrapper">

        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <div id="toc">
      </div>
      
			 
<ul class="toc-footer">

<li><a href='https://bons.ai/sign-up'>Sign Up for our Private Beta!</a></li>
<li><a href='https://github.com/BonsaiAI/slate'>Contribute to the Docs</a></li>
<li><a href='http://forums.bons.ai/'>Bonsai Forums</a></li>
<li><a href='mailto:support@bons.ai?subject=I need help with'>Email Us</a></li>
<li><a href='https://bons.ai'>Bonsai Home</a></li>

</ul>
       
        
	   <div class="cc-bottom"><ul class="toc-footer bottom">
<li><a href='https://creativecommons.org/licenses/by-nc-sa/4.0/'>Content:
	<span>CC-BY-NC-SA 4.0</span></a></li>	

<li><a href='https://creativecommons.org/licenses/by-nc-sa/4.0/'>
<svg class="cc" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
	 viewBox="0 0 70.7 13.4" style="enable-background:new 0 0 70.7 13.4;" xml:space="preserve">

<g>
	<g>
		<circle class="st0" cx="63.8" cy="6.7" r="6.1"/>
		<g>
			<path d="M63.9,0c1.9,0,3.5,0.7,4.8,2c1.3,1.3,2,2.9,2,4.8c0,1.9-0.6,3.5-1.9,4.7c-1.4,1.3-3,2-4.8,2c-1.8,0-3.4-0.7-4.7-2
				c-1.3-1.3-2-2.9-2-4.7c0-1.8,0.7-3.4,2-4.8C60.5,0.7,62.1,0,63.9,0z M64,1.2c-1.5,0-2.8,0.5-3.9,1.6c-1.1,1.1-1.6,2.4-1.6,3.9
				c0,1.5,0.5,2.8,1.6,3.9c1.1,1.1,2.4,1.6,3.9,1.6c1.5,0,2.8-0.5,3.9-1.6c1.1-1,1.6-2.3,1.6-3.9c0-1.5-0.5-2.8-1.6-3.9
				C66.8,1.8,65.5,1.2,64,1.2z M61,5.8c0.1-0.8,0.5-1.5,1-1.9c0.5-0.5,1.2-0.7,2-0.7c1.1,0,1.9,0.3,2.5,1c0.6,0.7,0.9,1.6,0.9,2.6
				c0,1-0.3,1.9-1,2.6c-0.6,0.7-1.5,1-2.5,1c-0.8,0-1.4-0.2-2-0.7c-0.6-0.5-0.9-1.1-1-1.9h1.7c0,0.8,0.5,1.2,1.5,1.2
				c0.5,0,0.9-0.2,1.1-0.6c0.3-0.4,0.4-1,0.4-1.6c0-0.7-0.1-1.3-0.4-1.6c-0.3-0.4-0.6-0.6-1.1-0.6c-0.9,0-1.4,0.4-1.5,1.2h0.5
				l-1.3,1.3l-1.3-1.3L61,5.8L61,5.8z"/>
		</g>
	</g>
	<g>
		<circle class="st0" cx="25.8" cy="6.8" r="5.9"/>
		<g>
			<path d="M25.8,0c1.9,0,3.5,0.6,4.8,1.9c1.3,1.3,2,2.9,2,4.8c0,1.9-0.6,3.5-1.9,4.7c-1.4,1.3-3,2-4.8,2c-1.8,0-3.4-0.7-4.7-2
				c-1.3-1.3-2-2.9-2-4.7c0-1.8,0.7-3.4,2-4.8C22.3,0.6,23.9,0,25.8,0z M25.8,1.2c-1.5,0-2.8,0.5-3.9,1.6c-1.1,1.1-1.6,2.4-1.6,3.9
				c0,1.5,0.5,2.8,1.6,3.9c1.1,1.1,2.4,1.6,3.9,1.6c1.5,0,2.8-0.5,3.9-1.6c1.1-1,1.6-2.3,1.6-3.9c0-1.5-0.5-2.8-1.6-3.9
				C28.6,1.7,27.3,1.2,25.8,1.2z M27.6,5v2.7h-0.8v3.3h-2.1V7.8H24V5c0-0.1,0-0.2,0.1-0.3c0.1-0.1,0.2-0.1,0.3-0.1h2.8
				c0.1,0,0.2,0,0.3,0.1C27.6,4.8,27.6,4.9,27.6,5z M24.9,3.3c0-0.6,0.3-0.9,0.9-0.9s0.9,0.3,0.9,0.9c0,0.6-0.3,0.9-0.9,0.9
				S24.9,3.9,24.9,3.3z"/>
		</g>
	</g>
	<g>
		<circle class="st0" cx="6.8" cy="6.7" r="6.1"/>
		<path d="M6.7,0c1.9,0,3.5,0.7,4.8,2c0.6,0.6,1.1,1.4,1.4,2.2c0.3,0.8,0.5,1.7,0.5,2.6c0,0.9-0.2,1.8-0.5,2.6
			c-0.3,0.8-0.8,1.5-1.4,2.1c-0.7,0.6-1.4,1.1-2.2,1.5c-0.8,0.3-1.7,0.5-2.6,0.5S5,13.3,4.2,12.9c-0.8-0.3-1.5-0.8-2.2-1.5
			s-1.1-1.4-1.5-2.2S0,7.6,0,6.7C0,5.8,0.2,5,0.5,4.2S1.3,2.6,2,2C3.3,0.7,4.8,0,6.7,0z M6.7,1.2c-1.5,0-2.8,0.5-3.9,1.6
			C2.3,3.4,1.9,4,1.6,4.6C1.4,5.3,1.2,6,1.2,6.7c0,0.7,0.1,1.4,0.4,2.1c0.3,0.7,0.7,1.3,1.2,1.8c0.5,0.5,1.1,0.9,1.8,1.2
			c0.7,0.3,1.4,0.4,2.1,0.4c0.7,0,1.4-0.1,2.1-0.4c0.7-0.3,1.3-0.7,1.8-1.2c1-1,1.6-2.3,1.6-3.9c0-0.7-0.1-1.4-0.4-2.1
			c-0.3-0.7-0.7-1.3-1.2-1.8C9.5,1.8,8.2,1.2,6.7,1.2z M6.6,5.6L5.7,6.1C5.6,5.9,5.5,5.7,5.4,5.6C5.3,5.6,5.1,5.5,5,5.5
			c-0.6,0-0.9,0.4-0.9,1.2c0,0.4,0.1,0.6,0.2,0.9C4.5,7.8,4.7,7.9,5,7.9c0.4,0,0.7-0.2,0.8-0.6l0.8,0.4C6.5,8.1,6.2,8.3,5.9,8.5
			c-0.3,0.2-0.7,0.3-1,0.3c-0.6,0-1.1-0.2-1.5-0.6C3.1,7.9,2.9,7.4,2.9,6.7c0-0.6,0.2-1.1,0.6-1.5c0.4-0.4,0.8-0.6,1.4-0.6
			C5.7,4.6,6.3,5,6.6,5.6z M10.5,5.6L9.6,6.1C9.5,5.9,9.4,5.7,9.3,5.6C9.1,5.6,9,5.5,8.9,5.5C8.3,5.5,8,5.9,8,6.7
			c0,0.4,0.1,0.6,0.2,0.9c0.2,0.2,0.4,0.3,0.7,0.3c0.4,0,0.7-0.2,0.8-0.6l0.8,0.4c-0.2,0.3-0.4,0.6-0.7,0.8c-0.3,0.2-0.7,0.3-1,0.3
			c-0.6,0-1.1-0.2-1.5-0.6C7,7.9,6.8,7.4,6.8,6.7c0-0.6,0.2-1.1,0.6-1.5c0.4-0.4,0.8-0.6,1.4-0.6C9.6,4.6,10.2,5,10.5,5.6z"/>
	</g>
	<g>
		<circle class="st0" cx="44.9" cy="6.8" r="6.2"/>
		<g>
			<path d="M44.9,0c1.9,0,3.5,0.6,4.8,1.9c1.3,1.3,2,2.9,2,4.8c0,1.9-0.6,3.5-1.9,4.7c-1.4,1.3-3,2-4.8,2c-1.8,0-3.4-0.7-4.7-2
				c-1.3-1.3-2-2.9-2-4.7c0-1.8,0.7-3.4,2-4.8C41.4,0.6,43,0,44.9,0z M39.7,4.9c-0.2,0.6-0.3,1.2-0.3,1.8c0,1.5,0.5,2.8,1.6,3.9
				c1.1,1.1,2.4,1.6,3.9,1.6c1.5,0,2.8-0.5,3.9-1.6c0.4-0.4,0.7-0.8,0.9-1.2l-2.5-1.1c-0.1,0.4-0.3,0.8-0.6,1
				c-0.3,0.3-0.7,0.4-1.2,0.5v1h-0.8v-1c-0.7,0-1.4-0.3-2-0.8L43.4,8c0.4,0.4,0.9,0.6,1.5,0.6c0.2,0,0.4-0.1,0.6-0.2
				c0.2-0.1,0.2-0.3,0.2-0.5c0-0.2-0.1-0.3-0.2-0.4l-0.6-0.3l-0.8-0.4l-1.1-0.5L39.7,4.9z M44.9,1.2c-1.5,0-2.8,0.5-3.9,1.6
				c-0.3,0.3-0.5,0.6-0.7,0.9l2.6,1.2c0.1-0.4,0.3-0.6,0.6-0.8c0.3-0.2,0.7-0.3,1.1-0.4v-1h0.8v1c0.6,0,1.2,0.2,1.7,0.6l-0.9,0.9
				c-0.4-0.3-0.8-0.4-1.2-0.4c-0.2,0-0.4,0-0.6,0.1c-0.2,0.1-0.2,0.2-0.2,0.4c0,0.1,0,0.1,0.1,0.2l0.9,0.4l0.6,0.3l1.1,0.5l3.4,1.5
				c0.1-0.5,0.2-1,0.2-1.4c0-1.5-0.5-2.8-1.6-3.9C47.7,1.7,46.4,1.2,44.9,1.2z"/>
		</g>
	</g>
</g>
</svg>
</li></a></ul></div>

    </div>
	      
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        
          <h1 id="overview">Overview</h1>

          <h2 id="introduction-to-inkling">Introduction to Inkling</h2>

<p>Welcome to Inkling, Bonsai AI&rsquo;s unique programming language for training AI.</p>

<p>Inkling is a declarative, strongly typed language that abstracts from the vast, dynamic AI algorithms that require expertise in machine learning. An Inkling file contains the concepts, what you want to teach the AI, and curriculum, how you want to teach the concepts, necessary to train your BRAIN.</p>

<p>This guide contains the following sections to help you get started writing Inkling files:</p>

<ul>
<li><strong><a href="#introduction-to-artificial-intelligence">Fundamentals</a>:</strong> An explanation of the various concepts you need to know for writing Inkling files. Learn about concepts, curriculums, schemas, and more.</li>
<li><strong><a href="#inkling-miscellany">Examples</a>:</strong> See Inkling in action. Check out some examples of Inkling code, and read our explanations of what and why. Then, try your had at one of our tutorials.</li>
<li><strong><a href="#under-the-hood">Under the Hood</a>:</strong> Inkling abstracts away from all of the ever changing AI algorithms that are out there, but if you want to know more about what&rsquo;s happening behind the scenes, check out this section!</li>
</ul>

<p>And don&rsquo;t forget to check out our other <a href=".">documentation</a>.</p>

          <h2 id="introduction-to-artificial-intelligence">Introduction to Artificial Intelligence</h2>

<p>This chapter is intended for developers who have never worked with machine learning.</p>

<p>Inkling is a programming language specifically designed for artificial intelligence (AI); it&rsquo;s a special purpose language. It abstracts away the vast world of dynamic AI algorithms that require expertise in machine learning and enables more developers to program AI. Before you read through this section about the Inkling language, you should familiarize yourself with the various components of the Bonsai Artificial Intelligence Engine, which you can read about in our <a href="getting-started.html">Getting Started Guide</a>.</p>

<h6 id="a-ten-thousand-foot-view">A Ten-Thousand Foot View</h6>

<p>A <a href="http://dictionary.cambridge.org/us/dictionary/english/10000-foot-view">ten-thousand foot view</a> of Inkling is described below, and includes a general description of the various components of an Inkling file.</p>

<h3 id="schemas-inputs-and-outputs">Schemas: Inputs and Outputs</h3>

<p><strong>Input</strong> is a stream of information that is fed into your BRAIN (your AI). The Bonsai AI Engine uses this information to help train the BRAIN or make a prediction.</p>

<p>In Inkling, <strong>Output</strong> is a stream of information returned as a prediction that your BRAIN sends back to an application. It could be sent back to a simulator, if training is in process, or it could be send back to your deployed application, where it might be used for control or optimization. The data in input and output streams are described by schemas. Schemas are declared in your Inkling program, and they contain information about the data types contained in the stream. For example, if you want to teach your AI,  to recognize the shape &lsquo;square&rsquo;, you might give it a picture of a shape. That picture would be an input. The BRAIN answers yes (this is a square) or no (this is not a square). That answer is the output. Your Inkling file to teach your AI would contain one schema for describing the data type of the input (Luminance, an image type) and another for the output (Bool). For more information about schemas, refer to <a href="#schemas">schema</a> in the reference section.</p>

<h3 id="mental-models-and-concepts">Mental Models and Concepts</h3>

<p>Mental models are a way of organizing concepts so that you can structure a solution to your AI problem as a workflow. Concepts are the ideas that you want to teach your BRAIN. When you create your concepts, you&rsquo;re going to start with the final concept that you want to teach your BRAIN and support it with other fact and strategy concepts. These additional concepts appear upstream of your main concept because the information output from those concepts helps the Bonsai AI Engine teach your main concept to your BRAIN. Mental Models enable you to determine and plan the concepts that are taught to your BRAIN.</p>

<p>For more information about Concepts, refer to <a href="#concepts">Concepts</a> and the <a href="reference.html#concept-reference">concept Reference</a>.</p>

<h3 id="curricula-and-lessons">Curricula and Lessons</h3>

<p>Curricula contain the lesson plan for the lessons that you are using to train your BRAINs. You must have one curriculum for every concept. A curriculum contains information about the training material that you&rsquo;re using to train the BRAIN; this is a simulator, generator, or data set, and it contains an objective, which measures the performance of the BRAIN as it learns your concept. Curricula may also contain expressions that assign portions of your training material for testing. Finally, your curriculum contains lessons. Each lesson teaches a piece of the concept. A curriculum can contain multiple lessons to teach a single concept.  Each lesson may contain different configurations for training the BRAIN. Configurations change how the Bonsai AI Engine uses the training source for training.</p>

<p><strong>Note:</strong> Currently, during our private beta, you can only train with simulators as your training sources. Additionally, you are limited to one lesson in your curriculum.</p>

<h3 id="chapter-summary">Chapter Summary</h3>

<p>In our Fundamentals Chapter, we go into greater detail about the various Inkling components mentioned above. These are broken into the following topics:</p>

<ul>
<li><a href="#inkling-a-new-language">Inkling: A New Language</a></li>
<li><a href="#mental-models">Mental Models</a></li>
<li><a href="#schemas">Schemas</a></li>
<li><a href="#concepts">Concepts</a></li>
<li><a href="#curricula-and-lessons">Curriculum and Lessons</a></li>
<li><a href="#objectives">Objectives</a></li>
</ul>

          <h2 id="inkling-a-new-language">Inkling: A New Language</h2>

<h3 id="what-kind-of-language-is-inkling">What kind of language is Inkling?</h3>

<p>Inkling is a special purpose language for writing AI programs. The language has a blend of declarative and functional styles; it&rsquo;s modeled after ideas in SQL and python. We like to describe Inkling as the world&rsquo;s first pedagogical programming language.  </p>

<h3 id="what-is-pedagogical-programming">What is Pedagogical Programming?</h3>

<h6 id="pedagogical-programming">Pedagogical Programming</h6>

<p>Pedagogical programming is a new programming paradigm. It expresses the solution to a problem in terms of how you teach the computer to find the solution as opposed to how to calculate the solution. Pedagogical programming focuses on:</p>

<ul>
<li><strong>What do you want the computer to know?</strong>
Pedagogical programming captures the concepts and their relationship to each other and forms a directed graph of the concepts.</li>
</ul>

<p>Imagine learning to play baseball; there are a lot of concepts involved. It goes beyond just the rules of the game, and includes things like batting stance, bat grip, eye hand coordination, etc.</p>

<ul>
<li><strong>How do you go about teaching those things?</strong>
Pedagogical programming focuses on how the problem can be taught, not how it can be calculated.</li>
</ul>

<p>Imagine teaching a child to play baseball. You can&rsquo;t just explain the whole game to them and expect them to understand how to play. You&rsquo;d break down learning into pieces, and create a series of lessons that would help them learn how to play baseball.</p>

<p>Let&rsquo;s say, to start, you wanted to teach them the concept of hand eye coordination. There would, likely, be a sequence of lessons to do this. You might start with a whiffle ball on a tee, progress to a tee that pops the ball up, move to underhand pitches, and then overhand pitches. You could continue to build upon your hand eye coordination concept with things like curved pitches, different styles of catching, and other exercises. It&rsquo;s all teaching one concept - eye hand coordination - but using <strong>progressive lessons</strong> to do so.</p>

<h6 id="inkling-is-a-special-purpose-language">Inkling is a Special Purpose Language</h6>

<p>Inkling is a special purpose language, meaning that it is a language for writing programs for a particular domain. This is as opposed to a general purpose language, which would allow you to write anything you could imagine. C++, Python, Ruby, and Java are all examples of general purpose programming languages.</p>

<h6 id="inkling-is-a-functional-language">Inkling is a Functional language</h6>

<p>In a functional programming language, a function defines a scope and can only modify what is in that scope. In Inkling, every concept takes data as input and sends data as output. Each concept is self contained, and there is no shared information between concepts unless you explicitly declare it. This means that no information is kept as state unless you specifically declare it. This makes Inkling a <a href="https://en.wikipedia.org/wiki/Functional_programming">functional programming</a> language.</p>

<p><strong>For example:</strong></p>

<ul>
<li>Python and Javascript can be programmed in a functional way, but they are not pure functional languages. F# is a pure functional programming language.</li>
<li>R, matlab, Java and prolog are not functional programming languages.</li>
</ul>

<h6 id="white-space-insensitive">White Space Insensitive</h6>

<p>Inkling is white space insensitive. Internally, we prefer to use four spaces to indent lines. This is a stylistic choice. In this document, any mention of an &ldquo;indentation&rdquo; or a line &ldquo;being indented&rdquo; refers to using four spaces at the start of a line.</p>

          <h1 id="details">Details</h1>

          <h2 id="mental-models">Mental Models</h2>

<p>Mental models are a way of organizing concepts so that you can structure your data flow. Concepts are the ideas that you want to teach your BRAIN.</p>

<h6 id="determining-mental-models">Determining Mental Models</h6>

<p>Your mental models should help you plan the concepts you&rsquo;re going to write in your Inkling file. Therefore, when you&rsquo;re determining your mental models, we suggest that you think about the condition that means the AI has successfully learned what you wanted it to learn. This could be:</p>

<ul>
<li>Learning to play a game</li>
<li>Learning to recognize what a handwritten digit is</li>
<li>Learning to tell if something is red or what color something is</li>
<li>Learning to save electricity in your home</li>
<li>Learning to manage a process to specific guidelines</li>
</ul>

<p>After you&rsquo;ve determined your success condition or criteria, you want to decide what the AI can do to prove it has successfully learned that condition. In a game, this could be, &ldquo;I think if the AI can get a high score, it has successfully learned to play the game.&rdquo; For recognizing red things, this could be, &ldquo;I think if the AI can successfully tell when something it is shown is red or not red it will have learned to recognize red things.&rdquo; This becomes your final <code class="prettyprint">concept</code>, and it also ties into your objective (reward), which measures how successful the AI is at learning this concept.</p>

<p>For more complex goals and many use cases, you need multiple concepts that all become part of training your final concept. These additional concepts support your final concept and can also reduce the time it takes to train your BRAIN. For more information about determining concepts, refer to the next chapter.</p>

<p>For each concept, you will need to determine what the AI needs to take in to make its decision and what the AI returns after it has decided. All of the information your AI needs to take in before it can train on any of the concepts is bundled together and labeled as <code class="prettyprint">input</code>. Each concept returns some information, but additional concepts feed their returned information to assist in training the final concept. Training on the final concept returns information that is sent from the BRAIN to the simulation. This is the <code class="prettyprint">output</code>.</p>

<p>Your mental model can be mapped from left to right, starting with your input. Your other concepts come next, followed by your final concept, and finally, to the right, is your output. Your output is fed back through the Bonsai AI Engine to the application. You can draw arrows between the various nodes to represent data flow. Your concepts are trained in order. To visualize this more clearly, see our expanded example below.</p>

<h6 id="examples">Examples</h6>

<h3 id="example-breakout">Example: Breakout</h3>
<pre class="highlight inkling"><code><span class="k">concept</span> <span class="nx">get_high_score</span>
  <span class="k">is</span> <span class="nx">classifier</span>
  <span class="k">predicts</span> <span class="p">(</span><span class="nx">PlayerMove</span><span class="p">)</span>
  <span class="k">follows</span> <span class="kr">input</span><span class="p">(</span><span class="nx">GameState</span><span class="p">)</span>
  <span class="k">feeds</span> <span class="kr">output</span>
<span class="k">end</span>
</code></pre>
<p>For example, our mental model for teaching an AI to play the game Breakout looks like this:</p>

<p><img src="https://daks2k3a4ib2z.cloudfront.net/57bf257ce45825764c5cb54b/57e8306180de1910630554d7_Screen%20Shot%202016-09-12%20at%2005.58.28.png" alt="57e8306180de1910630554d7 screen%20shot%202016 09 12%20at%2005.58.28" /></p>

<p>Single concept model for learning breakout</p>

<p>The <code class="prettyprint">input</code> is a snapshot of the game in its current state.</p>

<p>The concept <code class="prettyprint">get_high_score</code>, is our final <code class="prettyprint">concept</code>. It describes what we want our BRAIN to learn to play the Breakout simulation, which means we&rsquo;ve decided that being able to get a high score means that it&rsquo;s learned how to play the game. This single concept mental model is sufficient to train a BRAIN to play the game, but this training may take a long time.</p>

<p>The <code class="prettyprint">output</code> is the move that the AI wants to make. It chooses from left, right, or no move. The input and output are described in the schemas portion of the Inkling file.</p>

<p>To speed up training time and enable to learn the <code class="prettyprint">get_high_score</code> concept more concretely, you can expand this mental model and include more concepts.</p>
<pre class="highlight inkling"><code><span class="k">concept</span> <span class="nx">get_high_score</span>
  <span class="k">is</span> <span class="nx">classifier</span>
  <span class="k">predicts</span> <span class="p">(</span><span class="nx">PlayerMove</span><span class="p">)</span>
  <span class="k">follows</span> <span class="kr">input</span><span class="p">(</span><span class="nx">GameState</span><span class="p">),</span> <span class="nx">keep_paddle_under_ball</span>
  <span class="k">feeds</span> <span class="kr">output</span>
<span class="k">end</span>

<span class="k">concept</span> <span class="nx">keep_paddle_under_ball</span>
  <span class="k">is</span> <span class="nx">classifier</span>
  <span class="k">predicts</span> <span class="p">(</span><span class="nx">PlayerMove</span><span class="p">)</span>
  <span class="k">follows</span> <span class="kr">input</span><span class="p">(</span><span class="nx">GameState</span><span class="p">),</span> <span class="nx">ball_location</span>
  <span class="k">feeds</span> <span class="kr">output</span>
<span class="k">end</span>
</code></pre>
<p>In this example, we&rsquo;ve added two extra concepts that support our final concept and give our BRAIN more information to work with. The concept of <code class="prettyprint">ball_location</code> feeds information into the concept <code class="prettyprint">keep_paddle_under_ball</code>, and that concept feeds information into <code class="prettyprint">get_high_score</code>.</p>

<p>The input remains the same as above. The AI has two additional concepts to train. When it is training the ball_location concept, it takes in the input and returns the coordinates of the ball. On the <code class="prettyprint">keep_paddle_under_ball</code> concept, it takes in the input and the ball coordinates from ball_location. Then, that concept returns the best move to attempt to keep the paddle underneath the ball. The final concept, <code class="prettyprint">get_high_score</code>, takes in the input and the move returned from <code class="prettyprint">keep_paddle_under_ball</code> and returns the move it wants, which is the output sent to the simulator through the Bonsai AI Engine. Each of these concepts are trained from input to output.</p>

          <h2 id="schemas">Schemas</h2>

<p>Schemas describe a record and its fields. They contain a set of named data types that can be used throughout the system. They can include the common basic data types and native data types for working with common media formats (images, audio recordings). You add schemas in Inkling using the <strong>schema</strong> <a href="#schemas">keyword</a>.</p>

<p>Types (or <a href="https://en.wikipedia.org/wiki/Data_type">data types</a>) are representations of values of data. A type informs the system what the meaning of the data is, the possible values of that data is, what operations can be performed on that data, and the way the data can be stored. Types are the most basic building blocks of data manipulation.</p>

<p>In Inkling we need types, because the AI needs to understand the data it is sent. Also the AI needs to know how to represent the prediction it sends back to the program that you have deployed it with.</p>

<p>Inkling is also a strongly-typed language, which means that you are will receive an error if values are not compatible with their expected type. This means you need to pay attention to what types you choose.</p>

<p>Inkling supports various types, including (but not limited to) primitive types, which include types for integers, floats,  bytes and strings, as well as types commonly used with machine learning (for example, Luminance). See the section on schemas and Inkling types for more information.</p>

<h6 id="constrained-types">Constrained Types</h6>

<p>Inkling supports constrained types in schemas (as well as for configuration of lessons). Constrained types use range expressions to constrain the values of the type to values defined by a range expression.</p>

<p>A range expression has the effect of constraining the values of the type to values defined by the range expression. In a schema, this constrains the values in the field. In lessons, this constrains the values of the placeholder being configured. In both cases the syntax is the same.</p>

<p>Here are some examples of constrained types:</p>
<pre class="highlight inkling"><code><span class="k">schema</span> <span class="nx">MyOutput</span>
  <span class="kr">UInt8</span>  <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">}</span>   <span class="nx">label</span><span class="p">,</span>    <span class="c1"># a list of UInt8 values</span>
  <span class="kr">String</span> <span class="p">{</span><span class="s2">"a"</span><span class="p">,</span> <span class="s2">"bc"</span><span class="p">}</span>   <span class="nx">category</span><span class="p">,</span> <span class="c1"># a list of Strings</span>
  <span class="kr">Int64</span>  <span class="p">{</span> <span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span><span class="mi">100</span> <span class="p">}</span>   <span class="nx">x</span><span class="p">,</span>        <span class="c1"># start:step:stop, step= 5,0..100</span>
  <span class="kr">Int64</span>  <span class="p">{</span> <span class="mi">0</span><span class="p">:</span><span class="mi">100</span> <span class="p">}</span>     <span class="nx">y</span><span class="p">,</span>        <span class="c1"># start:stop, step= 1, 0..100</span>
  <span class="kr">Int64</span>  <span class="p">{</span> <span class="mi">0</span><span class="p">..</span><span class="mi">100</span><span class="p">:</span><span class="mi">25</span> <span class="p">}</span> <span class="nx">z</span><span class="p">,</span>        <span class="c1"># start:stop, numsteps=25, step= 4, 0..100</span>
  <span class="kr">Float32</span> <span class="p">{</span> <span class="mi">0</span><span class="p">..</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">}</span>    <span class="nx">a</span>         <span class="c1"># gives (0, .5., 1.0, 1.5, 2.0)</span>
<span class="k">end</span>
</code></pre>
<h6 id="defining-schemas">Defining Schemas</h6>

<p>Examine the input, returned data, and output of your mental model when defining your schemas. You need to match these requirements to Inkling types.</p>

<h3 id="how-to-pick-types">How to pick types</h3>

<ul>
<li>If your input is an image, you will need the <code class="prettyprint">luminance</code> type.</li>
<li>If your output is yes/no, true/false, or another dual relationship, you should use the <code class="prettyprint">bool</code> type.</li>
<li>Inkling supports signed and unsigned integers of various sizes as well as floating point (32 and 64 bit). More details can be found under <a href="#inkling-primitive-types">Inkling Primitive Types</a>.</li>
</ul>

          <h2 id="schemas-inkling-types-and-type-constraints">Schemas, Inkling Types, and Type Constraints</h2>

<p>Reference for the keyword <strong>schema</strong>. Also definitions and discussion of Inkling types and type constraints (which are both used in schema declarations).</p>

<h3 id="what-is-it">What is it?</h3>

<p><strong>schema</strong> (the keyword) describes a named record and its contained fields. Each field in a schema has a name and a type. A field may also have a type constraint that constrains the values that the datum described by this field will take.</p>

<h3 id="why-do-i-use-it">Why do I use it?</h3>

<p>Schemas describe the structure of data in Inkling  streams, such as the predefined input and output streams. In addition, many Inkling statements (for example <code class="prettyprint">concept</code> and <code class="prettyprint">curriculum</code> use schema references to describe the data that flows in and out of the construct.</p>

<h3 id="how-do-i-use-it">How do I use it?</h3>

<p>A sample schema declaration and use:</p>
<pre class="highlight inkling"><code><span class="k">schema</span> <span class="nx">MySchema</span>                   <span class="c1"># declare</span>
   <span class="kr">UInt8</span>  <span class="nx">field1</span><span class="p">,</span>
   <span class="kr">UInt32</span> <span class="nx">field2</span>
<span class="k">end</span>

<span class="k">concept</span> <span class="nx">MyConcept</span>
  <span class="k">is</span> <span class="nx">classifier</span>
    <span class="k">predicts</span> <span class="p">(</span><span class="nx">MySchema</span><span class="p">)</span>           <span class="c1"># use</span>
    <span class="k">follows</span> <span class="kr">input</span><span class="p">(</span><span class="kr">UInt64</span> <span class="nx">i</span><span class="p">)</span>       <span class="c1"># anonymous</span>
    <span class="k">feeds</span> <span class="kr">output</span>
<span class="k">end</span>
</code></pre>
<p>‍</p>

<h6 id="schema-rules">Schema Rules</h6>

<ul>
<li>Inkling statements can reference schemas by name. Above, <code class="prettyprint">MyConcept</code> uses <code class="prettyprint">MySchema</code> as its <code class="prettyprint">predicts</code> schema.</li>
<li>Statements can use anonymous schemas. That means that a list of fields appears where a schema name could appear. Above, after <code class="prettyprint">follows</code>, the predefined stream input has an anonymous schema with one field. This is useful in cases where you will only need that information once. In general, anywhere a schema name can appear, an anonymous schema can appear.</li>
<li>The set of types supported with schema fields consists of the set of Inkling primitive types and the set of Inkling structured types. These sets are listed below.</li>
<li>A schema field that has a primitive type can also have a type constraint that constrains the set of potential values for that field. Examples and syntax of type constraints are given below.</li>
</ul>

<h3 id="schema-declaration-syntax">Schema Declaration Syntax</h3>

<blockquote>
<p>schemaStmt :=</p>
</blockquote>
<pre class="highlight c"><code><span class="n">schema</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span>
  <span class="n">fieldDclnList</span>
<span class="n">end</span>
</code></pre>
<blockquote>
<p>fieldDclnList      :=</p>
</blockquote>
<pre class="highlight c"><code><span class="n">fieldDcln</span> <span class="p">[</span><span class="sc">','</span> <span class="n">fieldDcln</span>  <span class="p">]</span><span class="o">*</span>
</code></pre>
<blockquote>
<p>fieldDcln          :=</p>
</blockquote>
<pre class="highlight c"><code><span class="n">scalarDcln</span>                          <span class="o">|</span>
  <span class="n">structureDcln</span> <span class="c1">// see structured types
</span></code></pre>
<blockquote>
<p>scalarDcln         :=</p>
</blockquote>
<pre class="highlight c"><code><span class="n">primitiveType</span>
<span class="n">typeConstraint</span><span class="o">?</span>
<span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span>
<span class="p">[</span> <span class="sc">'['</span> <span class="n">arraySizeLiteral</span> <span class="sc">']'</span> <span class="p">]</span><span class="o">*</span>
</code></pre>
<p>‍</p>

<h3 id="schema-reference-syntax">Schema Reference Syntax</h3>

<p>A named schema is referenced by its name. An anonymous schema is referenced by its list of fields.</p>

<blockquote>
<p>schemaRef :=</p>
</blockquote>
<pre class="highlight c"><code>  <span class="sc">'('</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span> <span class="sc">')'</span>   <span class="c1">// named schema ref
</span><span class="o">|</span>
  <span class="sc">'('</span> <span class="o">&lt;</span><span class="n">fieldDclnList</span><span class="o">&gt;</span>  <span class="sc">')'</span>  <span class="c1">// anonymous schema ref
</span></code></pre>
<h6 id="inkling-primitive-types">Inkling Primitive Types</h6>

<p>Inkling has a set of primitive types which are used in schema declarations. The integer suffix indicates the size in bits of the type.</p>

<blockquote>
<p>primitiveType :=</p>
</blockquote>
<pre class="highlight c"><code><span class="n">Double</span> <span class="o">|</span> <span class="n">Float64</span> <span class="o">|</span> <span class="n">Float32</span> <span class="o">|</span> <span class="n">Int8</span> <span class="o">|</span> <span class="n">Int16</span> <span class="o">|</span> <span class="n">Int32</span> <span class="o">|</span>
<span class="n">Int64</span> <span class="o">|</span> <span class="n">UInt8</span> <span class="o">|</span> <span class="n">UInt16</span> <span class="o">|</span> <span class="n">UInt32</span>  <span class="o">|</span> <span class="n">UInt64</span> <span class="o">|</span> <span class="n">Bool</span> <span class="o">|</span> <span class="n">String</span>
</code></pre>
<h6 id="inkling-structured-types">Inkling Structured types</h6>

<p>Inkling supports the types Matrix and Luminance (more to come).</p>

<blockquote>
<p>structureDcln      :=</p>
</blockquote>
<pre class="highlight c"><code><span class="p">(</span> <span class="n">Luminance</span> <span class="o">|</span> <span class="n">Matrix</span> <span class="p">)</span>
  <span class="n">structureInit</span>
  <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span>
</code></pre>
<blockquote>
<p>structureInit      :=</p>
</blockquote>
<pre class="highlight c"><code><span class="sc">'('</span>

<span class="n">luminanceInit</span> <span class="o">|</span> <span class="n">matrixInit</span>

<span class="sc">')'</span>
</code></pre>
<blockquote>
<p>luminanceInit      :=</p>
</blockquote>
<pre class="highlight c"><code><span class="n">integerLiteral</span>  <span class="sc">','</span> <span class="n">integerLiteral</span>

<span class="n">matrixInit</span>         <span class="o">:=</span>
 <span class="sc">'('</span> <span class="n">concreteType</span>
  <span class="p">[</span> <span class="sc">','</span> <span class="n">concretetype</span> <span class="p">]</span><span class="o">*</span>
 <span class="sc">')'</span>

<span class="sc">','</span> <span class="n">integerLiteral</span> <span class="p">[</span> <span class="sc">','</span> <span class="n">integerLiteral</span><span class="p">]</span><span class="o">*</span>
</code></pre>
<h3 id="schema-example">Schema Example</h3>

<p>This example shows a schema that has a field with a primitive type and a field with a structured type.</p>
<pre class="highlight inkling"><code><span class="k">schema</span> <span class="nx">MNIST_training_data_schema</span>
  <span class="kr">UInt8</span> <span class="nx">label</span><span class="p">,</span>
  <span class="kr">Luminance</span><span class="p">(</span><span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span> <span class="nx">image</span>
<span class="k">end</span>
</code></pre>
<p>‍</p>

<h6 id="constrained-type">Constrained Type</h6>

<p>Constrained types are supported in schemas and also in <a href="#lesson">lessons</a>. They are constrained by means of a special type of expression called a range expression.</p>

<p>A range expression has the effect of constraining the values of the type to values defined by the range expression. In a schema this constrains the values in the field. In lessons this constrains the values of the placeholder being configured. In both cases the syntax is the same.</p>

<blockquote>
<p>Here are some examples of this syntax in a schema definition. Curly braces delineate the range expression.</p>
</blockquote>
<pre class="highlight inkling"><code><span class="k">schema</span> <span class="nx">MyOutput</span>
  <span class="kr">UInt8</span>  <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">}</span>   <span class="nx">label</span><span class="p">,</span>    <span class="c1"># a list of UInt8 values</span>
  <span class="kr">String</span> <span class="p">{</span><span class="s2">"a"</span><span class="p">,</span> <span class="s2">"bc"</span><span class="p">}</span>   <span class="nx">category</span><span class="p">,</span> <span class="c1"># a list of Strings</span>
  <span class="kr">Int64</span>  <span class="p">{</span> <span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span><span class="mi">100</span> <span class="p">}</span>   <span class="nx">x</span><span class="p">,</span>        <span class="c1"># start:step:stop, step= 5,0..100</span>
  <span class="kr">Int64</span>  <span class="p">{</span> <span class="mi">0</span><span class="p">:</span><span class="mi">100</span> <span class="p">}</span>     <span class="nx">y</span><span class="p">,</span>        <span class="c1"># start:stop, step= 1, 0..100</span>
  <span class="kr">Int64</span>  <span class="p">{</span> <span class="mi">0</span><span class="p">..</span><span class="mi">100</span><span class="p">:</span><span class="mi">25</span> <span class="p">}</span> <span class="nx">z</span><span class="p">,</span>        <span class="c1"># start:stop, numsteps=25, step= 4, 0..100</span>
  <span class="kr">Float32</span> <span class="p">{</span> <span class="mi">0</span><span class="p">..</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">}</span>    <span class="nx">a</span>         <span class="c1"># gives (0, .5., 1.0, 1.5, 2.0)</span>
<span class="k">end</span>
</code></pre>
<p>‍</p>

<h6 id="constrained-type-syntax">Constrained Type Syntax</h6>

<blockquote>
<p>constrainedType :=</p>
</blockquote>
<pre class="highlight c"><code><span class="n">numericType</span>
<span class="sc">'{'</span>
  <span class="n">start</span> <span class="sc">':'</span> <span class="p">[</span> <span class="n">step</span><span class="sc">':'</span><span class="p">]</span><span class="o">?</span> <span class="n">stop</span> <span class="c1">// 1:2:10.   Called a 'colon range'. Specifies 'step' (default=1).
</span>  <span class="o">|</span>
  <span class="n">start</span> <span class="sc">'.'</span> <span class="sc">'.'</span> <span class="n">stop</span> <span class="sc">':'</span> <span class="n">numSteps</span> <span class="c1">//   1..10:5  Called a 'dot range'. Specifies 'numsteps'.
</span><span class="sc">'}'</span>
</code></pre>
<blockquote>
<p>numericType :=</p>
</blockquote>
<pre class="highlight c"><code><span class="n">Double</span> <span class="o">|</span> <span class="n">Float64</span> <span class="o">|</span> <span class="n">Float32</span> <span class="o">|</span> <span class="n">Int8</span> <span class="o">|</span> <span class="n">Int16</span> <span class="o">|</span> <span class="n">Int32</span> <span class="o">|</span>  <span class="n">Int64</span> <span class="o">|</span> <span class="n">UInt8</span> <span class="o">|</span> <span class="n">UInt16</span> <span class="o">|</span> <span class="n">UInt32</span>  <span class="o">|</span> <span class="n">UInt64</span>
</code></pre>
<h6 id="constrained-type-rules">Constrained Type Rules</h6>

<h3 id="for-numeric-ranges">For numeric ranges:</h3>

<ul>
<li>For colon range, step can be  a floating point number.</li>
<li>For colon range, the step size can be negative only if stop &lt; start.</li>
<li>For dot range, number of steps (numSteps) is a positive integer.</li>
</ul>

<h3 id="schema-examples">Schema Examples:</h3>

<ul>
<li><strong>Int64  { 0:4:1 }</strong> is invalid. The step size is larger than the range.</li>
<li><strong>Int64  { 0..1:4 }</strong> is invalid. Values generated are floating point not integer.</li>
<li><strong>Float32{-1..1:10 }</strong> is valid. Negative bounds allowed.</li>
<li><strong>Int8 {0:-4:-100}</strong> is valid. stop  &lt; start is valid if and only if step is negative.</li>
<li><strong>UInt32 {-10:10}</strong> is invalid. Unsigned integer range contains signed values.</li>
</ul>

<p>For numeric ranges the start point is inclusive (it is included in the values of the range) and fixed. The end point may or may not be included in the values of the range. If you land on it exactly it is in the range. If you don&rsquo;t land on it exactly it is not in the range.</p>

<p>For example:</p>

<blockquote>
<p>Int8 { 0:3:10} gives you (0, 3, 6, 9).</p>
</blockquote>

<p>Note that the specification of 10 as the stop is not an error (because it is a limit, not necessarily an endpoint).</p>

<p>The range stop must be reachable from the range start by applying the step. (The range must be bounded.) The step is optional. If it is not specified the default value is 1. The step can be negative.</p>

<p>The range start is exact (to the maximum extent possible if the range expression type is floating point). The range end is a limit. That means that if applying the step results in landing exactly on the end point, then the end point is part of the range. Otherwise the highest value landed on that is less than the end point is the final value in the range.</p>

<p>‍</p>

          <h2 id="concepts">Concepts</h2>

<p>A <strong>concept</strong> in Inkling is an (abstract) idea. In Inkling, the concept defines what you are going to teach the AI. For more information about using the concept keyword, refer to the <a href="#concept-reference">concept reference</a>.</p>

<p>Every Inkling program needs at least one concept. If there is more than one, determine which one is your main concept. You may have additional concepts to assist in teaching the main concept to your AI.</p>

<h6 id="fact-and-strategy">Fact and Strategy</h6>

<p>When you&rsquo;re thinking about concepts, you can categorize them into two groups: fact and strategy. A fact concept describes the <em><strong>state</strong></em> of a thing or things, such as an object, a ball, a character, an enemy, a light, a person, etc. The fact concept could be the state of whether that thing is on or off, is hot or cold, is a number or a letter, etc. It can also be a location. A strategy concept describes a <em><strong>method</strong></em> or <em><strong>behavior</strong></em>, such as &ldquo;avoid ghosts&rdquo;, &ldquo;keep the paddle under the ball&rdquo;, &ldquo;don&rsquo;t run into walls&rdquo;, &ldquo;turn lights off&rdquo;.</p>

<p>For a simulator, your final concept is a strategy concept. Generator and data training sources don&rsquo;t permit strategy concepts.</p>

<h3 id="in-a-game">In a game</h3>

<p>If you want to teach your AI to play a game, first choose a main concept. The result of the AI learning this concept should be that it knows how to play the game.</p>

<ul>
<li>A <strong>fact concept</strong> would describe something about the current state of the game.</li>
<li>A <strong>strategy concept</strong> would describe a behavior that, if learned, would help the AI achieve its goal.</li>
</ul>

<p>For example, consider an Inkling program that teaches an AI to play Pacman. This is a game where you eat dots and run away from ghosts, and the higher the score you get, the better you do. Your main concept could be to get a high score.</p>

<p>Supporting concepts might include <code class="prettyprint">eat_dots</code>, <code class="prettyprint">avoid_ghosts</code>, <code class="prettyprint">eat_fruit</code>, and <code class="prettyprint">avoid_blue_ghosts</code>. These are strategy concepts. You may also have concepts called <code class="prettyprint">dot_location</code>, <code class="prettyprint">ghost_location</code>, or <code class="prettyprint">ghost_color</code>. These are fact concepts.</p>

<p>You can use a mental model to help you plan out your concepts and data flow.</p>

<h6 id="determining-concepts">Determining Concepts</h6>

<p>Determining what concepts to teach may take time. You can use mental models to work out what concepts to write and how data should flow between them.</p>

<h3 id="example-tetris">Example: Tetris</h3>

<p>Consider the game <a href="https://en.wikipedia.org/wiki/Tetris">Tetris</a>. The main concept we want to teach our AI will be the same as the main concept of PacMan. We want the AI to get the highest score possible. This represents that the AI has learned the game. To assist in teaching the main concept, we need to think through the various facts that the AI needs to learn. Here&rsquo;s a short list, but you might be able to think of other facts you&rsquo;d want to use:</p>

<ul>
<li><code class="prettyprint">active_tetrimino</code>: the tetrimino (piece) that is active. (fact)</li>
<li><code class="prettyprint">tetrimino_location</code>: the location of the active tetrimino. (fact)</li>
<li><code class="prettyprint">tetrimino_speed</code>: how fast the tetrimino is moving. (fact)</li>
<li><code class="prettyprint">clear_base</code>: fit tetriminos into the base to clear pieces of it. (strategy)</li>
</ul>

<p>Any of these facts could be written into supporting concepts that would give information to your main concept.</p>

<h3 id="example-home-automation">Example: Home Automation</h3>

<p>In our home automation example, let&rsquo;s imagine that we want to save energy by turning off the lights in empty rooms. Our main concept is going to be something like <code class="prettyprint">turn_off_lights_empty_rooms</code>. If the AI learns to do the main concept, then we&rsquo;ll have solved our problem. To support this main concept, we need to think about the various facts that the AI needs to know in order to accomplish that behavior. Here&rsquo;s a short list, but you might be able to think of other facts that you&rsquo;d want to use:</p>

<ul>
<li><code class="prettyprint">light_state</code>: the on/off state of the lights in each room. (fact)</li>
<li><code class="prettyprint">people_home</code>: The total number of people in the house. (fact)</li>
<li><code class="prettyprint">person_location</code>: The location of each person/the room each person is in. (fact)</li>
<li><code class="prettyprint">done_with_it</code>: The amount of time a person has been out of a room. Or, possibly, the location of the person who left this room. (fact)</li>
<li><code class="prettyprint">definitely_empty</code>: don&rsquo;t shut off lights if someone is coming right back. (strategy)</li>
<li><code class="prettyprint">still_in_use</code>: (a variant of the one above) don&rsquo;t turn off the lights if an empty room might be reoccupied soon.</li>
</ul>

<p>Any of these facts could be written into supporting concepts that would give information to your main concept.</p>

<h6 id="writing-concept-statements">Writing Concept Statements</h6>

<h3 id="classifier-and-estimator">Classifier and Estimator</h3>

<p>In Inkling, your concepts are written as concept statements. The Inkling concept statement includes an <strong>is</strong> clause which specifies whether the concept is a <strong>classifier</strong> or an <strong>estimator</strong>. This tells the AI what kind of information or prediction it is going to return.</p>

<p>In its simplest form, a classifier is taking in input and returning a classification. In reality, the classifier is taking in input and assigning a score to the possible classifications of that input from a given set. You would specify <code class="prettyprint">is classifier</code> on your concept if your outcome set is small and unchanging. For example, you want your AI to recognize a written number from 0-10. Your outcome set is 0,1,2,3,4,5,6,7,8,9,10. For every handwritten number that it is shown, it assigns a probability to each number and returns the most likely value (the one with the highest probability).</p>

<p>Estimators are used for larger outcome sets.  You would specify <code class="prettyprint">is estimator</code> on your concept if you are estimating a value in a very large range, potentially near infinite range. Estimators are often used for control. For example, if you need to turn a dial a certain amount, the AI has to return the direction and how much the dial is being turned. Your AI is estimating both of those from a potentially nearly-infinite range and returning the most likely combination.</p>

<h6 id="determining-concept-statements">Determining Concept Statements</h6>

<p>Determining what concepts to teach may take time. You can use mental models to work out what concepts need.  After you&rsquo;ve created your mental model, you can write your schemas (input and output) as well as your concepts. You need to:</p>

<ul>
<li>pick a descriptive name for your concept.</li>
<li>determine whether it is a <code class="prettyprint">classifier</code> or <code class="prettyprint">estimator</code></li>
<li>know where it comes in the mental model, and list any concepts that come before it.</li>
<li>for more information on the concept statement see <a href="#concept-reference">Concept Reference</a>.</li>
</ul>

<p>Every concept is trained by a curriculum. For more information about curricula, refer to <a href="#curricula-and-lessons">curricula and lessons</a>.</p>

<p>We suggest you check out all of our examples and tutorials to build your understanding of how to extract concepts out of your problems to enhance the training of your BRAINs.</p>

          <h2 id="concept-reference">Concept Reference</h2>

<p>Reference for the keyword <strong>concept</strong>. Also, describes the keywords: <strong>predicts</strong>, <strong>input</strong>, <strong>output</strong>, <strong>is</strong>, <strong>follows</strong>, <strong>end</strong>, and <strong>feeds</strong>.</p>

<h3 id="what-is-it">What is it?</h3>

<p><strong>concept</strong> (the keyword) declares an abstract concept (the idea) for the system to learn.</p>

<h3 id="why-do-i-use-it">Why do I use it?</h3>

<p>A concept statement describes what the computer will learn. It can be a feature (such as a curvy line in an image) or a goal (such as high score in a game).</p>

<h3 id="how-do-i-use-it">How Do I Use It?</h3>

<p>A typical concept statement:</p>
<pre class="highlight inkling"><code><span class="k">concept</span> <span class="nx">conceptName</span>
  <span class="k">is</span> <span class="p">(</span><span class="nx">classifier</span> <span class="o">|</span> <span class="nx">estimator</span><span class="p">)</span>
  <span class="k">predicts</span> <span class="p">(</span><span class="nx">outputSchema</span><span class="p">)</span>
  <span class="k">follows</span> <span class="nx">preceedingConcept1</span><span class="p">,</span> <span class="kr">input</span><span class="p">(</span><span class="nx">schemaName</span><span class="p">)</span>
  <span class="k">feeds</span> <span class="kr">output</span><span class="p">,</span> <span class="nx">subsequentconcept</span>
<span class="k">end</span>
</code></pre>
<h6 id="breakdown-of-concept-statement">Breakdown of Concept statement</h6>

<ul>
<li><code class="prettyprint">concept</code>: declares an abstract concept for the system to learn.</li>
<li><code class="prettyprint">is</code>: specifies the kind of prediction the trained concept will produce (<strong>classifier</strong> or <strong>estimator</strong>).</li>
<li><code class="prettyprint">predicts</code>: declares the concept&rsquo;s output.</li>
<li><code class="prettyprint">follows</code>: declares the concepts or streams the concept gets input from.</li>
<li><code class="prettyprint">feeds</code>: declares the list of concepts and streams that have this concept&rsquo;s output as input.</li>
<li><code class="prettyprint">end</code>: delimiter that declares the end of this statement.</li>
</ul>

<h6 id="concept-statement-syntax">Concept Statement Syntax</h6>

<blockquote>
<p>conceptStmt :=</p>
</blockquote>
<pre class="highlight c"><code><span class="n">concept</span>
  <span class="n">is</span> <span class="p">[</span> <span class="n">classifier</span> <span class="o">|</span> <span class="n">estimator</span> <span class="p">]</span>
  <span class="n">predicts</span> <span class="p">(</span> <span class="n">schemaRef</span> <span class="p">)</span>
  <span class="p">[</span>
    <span class="n">follows</span>
      <span class="n">inputSource</span> <span class="p">[</span><span class="sc">','</span> <span class="n">inputSource</span> <span class="p">]</span><span class="o">*</span>
    <span class="p">]</span><span class="o">?</span>
  <span class="p">[</span>
    <span class="n">feeds</span>
      <span class="n">outputTarget</span> <span class="p">[</span><span class="sc">','</span> <span class="n">outputTarget</span> <span class="p">]</span><span class="o">*</span>

  <span class="p">]</span><span class="o">?</span>
<span class="n">end</span>
</code></pre>
<blockquote>
<p>inputSrc :=</p>
</blockquote>
<pre class="highlight c"><code>  <span class="n">input</span> <span class="sc">'('</span> <span class="n">schemaRef</span><span class="o">?</span> <span class="sc">')'</span> <span class="o">|</span>  <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span> <span class="c1">// concept or stream name
</span></code></pre>
<blockquote>
<p>outputTarget :=</p>
</blockquote>
<pre class="highlight c"><code>  <span class="n">output</span> <span class="o">|</span> <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span>                    <span class="c1">// concept or stream name
</span></code></pre>
<h6 id="concept-rules">Concept Rules</h6>

<ul>
<li>The concept must be named after the <code class="prettyprint">concept</code> keyword.</li>
<li>The <code class="prettyprint">is</code> keyword specifies the kind of prediction the trained concept will produce. For example, a concept can specify is classifier. This means that the trained concept will categorize its input. Email, for example, can be classified as spam or not spam. Another option with this keyword is estimator.</li>
<li>The concept must declare an output schema after <code class="prettyprint">predicts</code>. The output schema describes the data produced by the trained concept. For example if this concept classifies email into spam and not spam, the output schema for the concept would be a Bool. The output schema can be a named schema, where the name refers to a full schema definition elsewhere, or it can be anonymous, which is a parenthesized list of name, type pairs. See the section on schema declarations for more information.</li>
<li>A trained concept gets input from streams or (if multiple concepts are used) from another concept. Input (the keyword) refers to the stream that is the original input to the system. All data flowing through the system has a schema associated with it. In some cases this is calculated rather than explicit.</li>
<li>If the input keyword appears in the <code class="prettyprint">follows</code> list, it means that the input stream flowing into this concept comes from outside the BRAIN. The input keyword must always be accompanied by a schema (named or anonymous) because the data stream originates outside the Brain; if no schema was present, data types and formats being input would be unknown.</li>
<li>The <code class="prettyprint">feeds</code> list is a list of concepts and streams (including the predefined output stream) for which this concept&rsquo;s output is a source.</li>
<li>The input keyword cannot not appear in the feeds list and the output keyword cannot appear in the follows list.</li>
<li>The concept statement is terminated by the <code class="prettyprint">end</code> keyword.</li>
</ul>

<h6 id="concept-examples">Concept Examples</h6>

<blockquote>
<p>Concept get_high_score:</p>
</blockquote>
<pre class="highlight inkling"><code><span class="k">concept</span> <span class="nx">get_high_score</span>
  <span class="k">is</span> <span class="nx">classifier</span>
  <span class="k">predicts</span> <span class="nx">PlayerMove</span>
  <span class="k">follows</span> <span class="kr">input</span><span class="p">(</span><span class="nx">GameState</span><span class="p">)</span>
  <span class="k">feeds</span> <span class="kr">output</span>
<span class="k">end</span>
</code></pre>
<h3 id="get-high-score">Get High Score</h3>

<p>In this example:</p>

<ul>
<li><code class="prettyprint">conceptName</code>: get_high_score</li>
<li><code class="prettyprint">class</code>: classifier</li>
<li><code class="prettyprint">outputSchema</code>: PlayerMove</li>
<li><code class="prettyprint">input(schemaName)</code>: input(GameState)</li>
<li><code class="prettyprint">dependent</code>: output</li>
</ul>

<h3 id="digit">Digit</h3>

<p>Our concepts are Digit, Curvature, and Segments. In this example:</p>

<blockquote>
<p>Concept Digit:</p>
</blockquote>
<pre class="highlight inkling"><code><span class="k">concept</span> <span class="nx">Digit</span>
  <span class="k">is</span> <span class="nx">classifier</span>
  <span class="k">predicts</span> <span class="nx">MNIST_output</span>
  <span class="k">follows</span> <span class="nx">Curvature</span><span class="p">,</span> <span class="nx">Segments</span><span class="p">,</span> <span class="kr">input</span><span class="p">(</span><span class="nx">MNIST_input</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<h3 id="digit">Digit</h3>

<ul>
<li><code class="prettyprint">conceptName</code>: Digit</li>
<li><code class="prettyprint">kind</code>: classifier</li>
<li><code class="prettyprint">predicts</code>: MNIST_output</li>
<li><code class="prettyprint">follows</code></li>
<li><code class="prettyprint">Curvature</code>: a concept</li>
<li><code class="prettyprint">Segments</code>: another concept</li>
<li><code class="prettyprint">input(MNIST_input)</code>: The input keyword indicates the predefined input    stream with data formats defined by schema MNIST_input.</li>
<li><code class="prettyprint">feeds:</code> output</li>
</ul>

<blockquote>
<p>Concept Curvature:</p>
</blockquote>
<pre class="highlight inkling"><code><span class="k">concept</span> <span class="nx">Curvature</span>
  <span class="k">is</span> <span class="nx">classifier</span>
  <span class="k">predicts</span> <span class="p">(</span><span class="nx">curve_output</span><span class="p">)</span>
  <span class="k">follows</span> <span class="kr">input</span><span class="p">(</span><span class="nx">MNIST_input</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<h3 id="curvature">Curvature</h3>

<ul>
<li><code class="prettyprint">conceptName</code>: Curvature</li>
<li><code class="prettyprint">kind</code>: classifier</li>
<li><code class="prettyprint">predicts</code>: curve_output</li>
<li><code class="prettyprint">follows</code>:</li>
<li><code class="prettyprint">input(MNIST_input)</code>: The input keyword indicates the predefined input    stream with data formats defined by schema MNIST_input.</li>
</ul>

<blockquote>
<p>Concept Segments</p>
</blockquote>
<pre class="highlight inkling"><code><span class="k">concept</span> <span class="nx">Segments</span>
  <span class="k">is</span> <span class="nx">classifier</span>
  <span class="k">predicts</span> <span class="p">(</span><span class="nx">segments_output</span><span class="p">)</span>
  <span class="k">follows</span> <span class="kr">input</span><span class="p">(</span><span class="nx">MNIST_input</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<h3 id="segments">Segments</h3>

<ul>
<li><code class="prettyprint">conceptName</code>: Segments</li>
<li><code class="prettyprint">kind</code>: classifier</li>
<li><code class="prettyprint">predicts</code>: segments_output</li>
<li><code class="prettyprint">follows</code>:</li>
<li><code class="prettyprint">input(MNIST_input)</code>: The input keyword indicates the predefined input    stream with data formats defined by schema MNIST_input.</li>
</ul>

          <h2 id="curricula-and-lessons">Curricula and Lessons</h2>

<p>A <strong>curriculum</strong> in Inkling is used to define what and how to teach a concept. Each concept needs a corresponding curriculum to teach it, and every Inkling program must contain at least one curriculum. A <strong>lesson</strong> is part of a curriculum; it teaches a specific piece of the concept by specifying training and testing parameters and a stopping point (<strong>until</strong>). Lessons enable the AI to learn the concept bit-by-bit instead of all at once. Lessons are contained within curriculum statements. Each curriculum must contain at least one lesson.</p>

<h6 id="determining-a-curriculum">Determining a Curriculum</h6>

<p>Each curriculum trains a single concept, and every concept must have a curriculum. After you&rsquo;ve determined your concepts, you will know how many curricula you need for your Inkling program. Curricula contain the information the Bonsai AI Engine uses to train your BRAIN on the concepts you&rsquo;ve specified. They also specify the reward function (<strong>objective</strong>) for teaching a given concept. The reward function is a way the system concretely measures the AI&rsquo;s performance as it learns the concept.</p>
<pre class="highlight inkling"><code><span class="k">curriculum</span> <span class="nx">balance_curriculum</span>
    <span class="k">train</span> <span class="nx">balance</span>
    <span class="k">with</span> <span class="k">simulator</span> <span class="nx">cartpole_simulator</span><span class="p">(</span><span class="nx">CartPoleConfig</span><span class="p">)</span> <span class="p">:</span> <span class="p">(</span><span class="nx">GameState</span><span class="p">)</span>
    <span class="k">objective</span> <span class="nx">open_ai_gym_default_objective</span>
      <span class="c1">#lessons</span>
<span class="k">end</span>
</code></pre>
<h6 id="determining-lessons">Determining Lessons</h6>

<p>Each lesson specifies a portion of the training and, depending on the training sources, may contain information on configuring the training sources, training, testing, and a stopping point (<strong>until</strong>). When you&rsquo;re determining your lessons, you need to consider what your training sources are and what piece of the concept you are training. For example, if you&rsquo;re training with a simulator, you can place constraints on your simulation during training.</p>

<h3 id="configure-clause">Configure Clause</h3>

<p>The configure clause is part of a lesson statement. Configure clauses are used with simulators and generators. They inform the computer how to set up the simulator or generator for training. You use configure to make sure you&rsquo;re not always training from the beginning, but from a point that makes sense to enhance how your BRAIN is learning the concepts.</p>

<p>The configure clause uses the <strong>constrain</strong> keyword to create a set of conditions for the AI to train on the simulator or generator with. <strong>constrain</strong> references a schema that is associated with the simulator.</p>
<pre class="highlight inkling"><code><span class="k">lesson</span> <span class="nx">get_high_score</span>
  <span class="k">configure</span>
    <span class="k">constrain</span> <span class="nx">episode_length</span> <span class="k">with</span> <span class="kr">Int8</span><span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">},</span>
    <span class="k">constrain</span> <span class="nx">num_episodes</span> <span class="k">with</span> <span class="kr">Int8</span><span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">},</span>
    <span class="k">constrain</span> <span class="nx">deque_size</span> <span class="k">with</span> <span class="kr">UInt8</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span>
  <span class="k">until</span>
    <span class="k">maximize</span> <span class="nx">open_ai_gym_default_objective</span>
</code></pre>
<p>The configure clause supports placeholders as well. The placeholder name does not hold a specific value, but is a name of a range of values that the the Bonsai AI Engine inputs during training. The configure clause provides guidance to the Bonsai AI Engine on how the training for that lesson should be configured. It is not the same as an assignment in an imperative language, because it does not represent a unique value. The AI Engine has some degree of freedom in determining how to configure for training.</p>

<p>For more information and examples, refer to the <a href="#curriculum">curriculum reference</a>.</p>

          <h2 id="curriculum">Curriculum</h2>

<p>Reference for the keyword <strong>curriculum</strong>. Also, describes the keywords: <strong>train</strong>, <strong>with</strong>, <strong>data</strong></p>

<h3 id="what-is-it">What is it?</h3>

<p>The <strong>curriculum</strong> (keyword) declares a set of lessons that are used to teach concepts. Each curriculum contains a lesson or set of lessons and trains a single concept.</p>

<h3 id="why-do-i-use-it">Why do I use it?</h3>

<p>A curriculum is used to teach a concept. The curriculum defines what concept is being taught (see the train clause below). Every concept needs a corresponding curriculum to teach it. A curriculum defines a set of lessons used to train the concept.</p>

<h3 id="how-do-i-use-it">How do I use it?</h3>

<p>Here is the simple form of a curriculum statement:</p>
<pre class="highlight inkling"><code><span class="k">curriculum</span> <span class="nx">curriculumName</span>
  <span class="k">train</span> <span class="nx">conceptName</span>
  <span class="k">with</span> <span class="nx">trainingSpecifier</span>  <span class="c1">#trainingSpecifier can be data, simulator, or generator</span>
  <span class="k">objective</span> <span class="nx">objectiveName</span>
    <span class="c1">#lessons are specified here.</span>
<span class="k">end</span>
</code></pre>
<p>The trainingSpecifier specifies either <code class="prettyprint">data</code>, <code class="prettyprint">simulator</code>, or <code class="prettyprint">generator</code> as the training source. These support different approaches to training. For <strong>data</strong>, a set of labeled data is available for training and testing. A labeled dataset contains data plus meta information about the data, for example an image of a hat plus the category of the image (&lsquo;hat&rsquo;). The labels assist training and also support testing. The availability of labeled data means that coded simulators are unnecessary. After training with the labeled data of images of hats, the BRAIN is able to identify a hat in an unlabeled image.</p>

<p>In the <strong>simulator</strong> case, all the data is unlabeled and the response to training data will be fed back into the training. A separately coded <code class="prettyprint">simulator</code> (written in python for example) provides implementations of the lessons and keep the state of training. The <strong>generator</strong> case is like the <strong>simulator</strong> case (in that there is a separately coded generator and the data is unlabeled), but the generator is stateless.</p>

<p><strong>Note:</strong> Currently, during our private beta, you can <strong>only</strong> train with simulators as your training source. That is, training specifier <strong>simulator</strong> is supported, but <strong>data</strong> and <strong>generator</strong> are not.</p>

<p>The <strong>objective</strong> specifies the termination condition for training.</p>

<p><strong>Note:</strong> When the trainingSpecifier is <strong>data</strong>, the objective must be either the keywords <code class="prettyprint">equality</code> or <code class="prettyprint">linear_distance</code>. When the training specifier is <strong>simulator</strong> or <strong>generator</strong>, the objective names a function which is specified in the associated simulator or generator. The use of simulators or generators requires an auxiliary clause, the <code class="prettyprint">simulator</code> or <code class="prettyprint">generator</code> clause respectively. The example below uses the game Mountain Car from OpenAI Gym to illustrate the simulator clause.  To explore this example more fully, refer to it in our <a href="inkling.html#example-mountain-car">Examples chapter</a>.</p>
<pre class="highlight inkling"><code><span class="k">simulator</span> <span class="nx">mountaincar_simulator</span><span class="p">(</span><span class="nx">MountainCarConfig</span><span class="p">)</span> <span class="c1">#simulator clause</span>
  <span class="k">state</span> <span class="p">(</span><span class="nx">GameState</span><span class="p">)</span>
  <span class="nx">control</span> <span class="p">(</span><span class="nx">Action</span><span class="p">)</span>
<span class="k">end</span>
</code></pre><pre class="highlight inkling"><code><span class="k">curriculum</span> <span class="nx">high_score_curriculum</span>
<span class="k">train</span> <span class="nx">high_score</span>
<span class="k">with</span> <span class="k">simulator</span> <span class="nx">mountaincar_simulator</span> <span class="c1"># with simulator clause</span>
<span class="k">objective</span> <span class="nx">open_ai_gym_default_objective</span>
  <span class="k">lesson</span> <span class="nx">get_high_score</span>
    <span class="k">configure</span>
      <span class="k">constrain</span> <span class="nx">episode_length</span> <span class="k">with</span> <span class="kr">Int8</span><span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">},</span>
      <span class="k">constrain</span> <span class="nx">num_episodes</span> <span class="k">with</span> <span class="kr">Int8</span><span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">},</span>
      <span class="k">constrain</span> <span class="nx">deque_size</span> <span class="k">with</span> <span class="kr">UInt8</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span>
    <span class="k">until</span>
      <span class="k">maximize</span> <span class="nx">open_ai_gym_default_objective</span>
<span class="k">end</span>
</code></pre>
<p>‍</p>

<p>The simulator clause declares the simulator name and two schemas. The first specifies the schema for configuration of the simulator and it appears in parentheses immediately after the simulator name. In this instance, the configuration schema is named <code class="prettyprint">MountainCarConfig</code>. In the example, the configure clause of lesson <code class="prettyprint">get_high_score</code> initializes this configuration.</p>

<blockquote>
<p>Schema Declaration:</p>
</blockquote>
<pre class="highlight inkling"><code><span class="k">schema</span> <span class="nx">MountainCarConfig</span>
  <span class="kr">Int8</span> <span class="nx">episode_length</span><span class="p">,</span>
  <span class="kr">Int8</span> <span class="nx">num_episodes</span><span class="p">,</span>
  <span class="kr">UInt8</span> <span class="nx">deque_size</span>
<span class="k">end</span>
</code></pre>
<p>The names in this schema are the names referenced in the configure clause of <code class="prettyprint">lesson get_high_score</code>.</p>

<p>The second schema specified in the simulator clause is the state schema. It is specified after the <code class="prettyprint">state</code> keyword in the simulator clause. This is the schema that defines what is sent to the lesson. Recall that a simulator has state. That means that input to the lesson will consist of the state of the game as a result of the previous lesson execution. For mountaincar this schema is called GameState and prior state consists of prior position.</p>

<blockquote>
<p>GameState Definition</p>
</blockquote>
<pre class="highlight inkling"><code><span class="k">schema</span> <span class="nx">GameState</span>
  <span class="kr">Float32</span> <span class="nx">x_position</span><span class="p">,</span>
  <span class="kr">Float32</span> <span class="nx">x_velocity</span>
<span class="k">end</span>
</code></pre>
<p>In order to determine what our next move will be, the training will use the previous position as input.</p>

<p>Finally, note that high_score_curriculum trains a concept called high_score.  (It&rsquo;s quite clear what we are aiming for with this curriculum!)</p>

<blockquote>
<p>Concept high_score, with its <strong>predict</strong> schema Action:</p>
</blockquote>
<pre class="highlight inkling"><code><span class="k">schema</span> <span class="nx">Action</span>
  <span class="kr">Int8</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span> <span class="k">action</span> <span class="c1"># an enum whose values describe game moves</span>
<span class="k">end</span>

<span class="k">concept</span> <span class="nx">high_score</span>
  <span class="k">is</span> <span class="nx">classifier</span>
  <span class="k">predicts</span> <span class="p">(</span><span class="nx">Action</span><span class="p">)</span>
  <span class="k">follows</span> <span class="kr">input</span><span class="p">(</span><span class="nx">GameState</span><span class="p">)</span>    <span class="k">feeds</span> <span class="nx">outputend</span>
</code></pre>
<p>The concept high_score trains the Brain to select the next move, which is an Action. Note that the predefined input stream <strong>input</strong> has the schema GameState. This reflects that fact that the simulator has state. The previous move is the state which is input into the selection of the next move.</p>

<p>The <strong>predicts</strong> schema Action also appears in the simulator clause discussed above. It is after the keyword <strong>control</strong>. In general the <strong>control</strong> schema is the <strong>predicts</strong> schema of the concept being trained.</p>

<p>So far we have presented a simple version of the curriculum. Inkling supports multiple simulators and generators within a single curriculum. Here is the full syntax for the curriculum statement, which introduces a usingClause and a withClause (where <strong>using</strong> and <strong>with</strong> will specify simulators). These were not needed in our example above because we were using a single simulator.</p>

<h6 id="curriculum-statement-syntax">Curriculum Statement Syntax</h6>

<blockquote>
<p>curriculumStmt :=</p>
</blockquote>
<pre class="highlight inkling"><code><span class="k">curriculum</span> <span class="o">&lt;</span><span class="nx">name</span><span class="o">&gt;</span>
    <span class="k">train</span> <span class="o">&lt;</span><span class="nx">conceptName</span><span class="o">&gt;</span>
<span class="p">[</span>
  <span class="nx">withClause</span>                        <span class="c1"># with clause</span>

<span class="p">]</span><span class="o">+</span><span class="p">[</span>
  <span class="k">using</span>  <span class="p">[</span> <span class="o">&lt;</span><span class="nx">simulatorName</span><span class="o">&gt;</span> <span class="o">|</span> <span class="k">data</span> <span class="p">]</span> <span class="c1"># using clause</span>
  <span class="p">[</span>
    <span class="nx">assignClause</span> <span class="c1"># assignment for training and test data</span>
    <span class="nx">lessonClause</span> <span class="c1"># lesson set for this simulator</span>
  <span class="p">]</span><span class="o">+</span>

  <span class="k">end</span> <span class="c1"># using</span>
<span class="p">]</span><span class="o">+</span>
<span class="k">end</span> <span class="c1"># curriculum</span>
</code></pre>
<blockquote>
<p>withClause :=</p>
</blockquote>
<pre class="highlight inkling"><code><span class="k">with</span> <span class="k">data</span>
  <span class="k">objective</span> <span class="o">&lt;</span><span class="nx">objectiveFunctionName</span><span class="o">&gt;</span>

<span class="o">|</span> <span class="k">with</span> <span class="k">simulator</span>
  <span class="k">objective</span> <span class="o">&lt;</span><span class="nx">objectiveFunctionName</span><span class="o">&gt;</span>

<span class="o">|</span> <span class="k">with</span> <span class="k">generator</span>
  <span class="k">objective</span> <span class="o">&lt;</span><span class="nx">objectiveFunctionName</span><span class="o">&gt;</span>
</code></pre>
<p>Any simulator or generator referenced in a curriculum must have an associated simulator or generator clause.</p>

<h6 id="simulator-generator-clause-syntax">Simulator / Generator Clause Syntax</h6>
<pre class="highlight c"><code><span class="n">simulator</span> <span class="o">&lt;</span><span class="n">simulatorName</span><span class="o">&gt;</span><span class="sc">'('</span><span class="o">&lt;</span><span class="n">configurationSchema</span><span class="o">&gt;</span><span class="sc">')'</span> <span class="c1">// simulator clause
</span>  <span class="n">state</span> <span class="sc">'('</span><span class="o">&lt;</span><span class="n">stateSchema</span><span class="o">&gt;</span><span class="sc">')'</span> <span class="c1">// simulator state
</span>  <span class="n">control</span> <span class="sc">'('</span><span class="o">&lt;</span><span class="n">controlSchema</span><span class="o">&gt;</span><span class="sc">')'</span> <span class="c1">// training concept predicts schema
</span><span class="n">end</span>
</code></pre><pre class="highlight c"><code><span class="n">generator</span> <span class="o">&lt;</span><span class="n">generatorName</span><span class="o">&gt;</span><span class="sc">'('</span><span class="o">&lt;</span><span class="n">configurationSchema</span><span class="o">&gt;</span><span class="sc">')'</span>  <span class="c1">// generator clause
</span>  <span class="n">yield</span> <span class="sc">'('</span><span class="o">&lt;</span><span class="n">outputSchema</span><span class="o">&gt;</span><span class="sc">')'</span>    <span class="c1">// generator output (yield)
</span><span class="n">end</span>
</code></pre>
<h6 id="curriculum-rules">Curriculum Rules</h6>

<ul>
<li>One curriculum per concept. Also, every concept must have a curriculum.</li>
<li>You can train with <strong>data</strong>, <strong>simulators</strong>, or <strong>generators</strong>. These are the values allowed as training specifiers. Also, every simulator or generator must be declared with a simulator or generator clause, respectively.</li>
</ul>

<p><strong>Note:</strong> Currently, during our private beta, you can <strong>only</strong> train with simulators as your training material. That is, only the <strong>simulator</strong> training specifier is supported.</p>

<ul>
<li>Lessons, tests, and assignments can occur in any order. (Assignments are used for data handling when the training specifier is <strong>data</strong>.)</li>
<li>If the <code class="prettyprint">using</code> Clause is present (that is, if the simplified curriculum syntax is not being used), there must be one usingClause for every withClause.</li>
<li>The objective is always required but if the trainingSpecifier is <strong>data</strong>, the objective must be either equality or linear_distance.</li>
</ul>

<h6 id="curriculum-examples">Curriculum Examples</h6>

<blockquote>
<p>Our curriculum is to train the get_high_score concept.</p>
</blockquote>
<pre class="highlight inkling"><code><span class="k">curriculum</span> <span class="nx">get_high_score_curriculum</span>
  <span class="k">train</span> <span class="nx">get_high_score</span>
  <span class="k">with</span> <span class="k">simulator</span> <span class="nx">breakout_simulator</span>
  <span class="k">objective</span> <span class="nx">score</span>
    <span class="c1">#lesson</span>
<span class="k">end</span>
</code></pre>
<h3 id="get-high-score">get high score</h3>

<p>‍
In this example:</p>

<ul>
<li><strong>curriculumName:</strong> get_high_score_curriculum</li>
<li><strong>conceptName:</strong> get_high_score</li>
<li><strong>trainingSpecifier:</strong> simulator</li>
<li><strong>simulator</strong> the keyword to indicate that this is training on a simulator</li>
<li><strong>simulatorName</strong>: breakout_simulator</li>
<li><strong>objectiveName:</strong> score</li>
</ul>

<h3 id="digit">digit</h3>

<p>This curriculum trains the Digit concept. This example references the MNIST database which is used to train for recognition of handwritten digits.  This example shows the use of the <strong>data</strong> training specifier (which is not supported during private beta) for that data set. When training <strong>with data</strong> the labeled data set must be read in from a file and then prepared and split into training and test partitions. That is shown below.</p>
<pre class="highlight inkling"><code><span class="k">from</span> <span class="nx">utils</span> <span class="k">import</span> <span class="nx">split</span>

<span class="k">schema</span> <span class="nx">MNIST_schema</span>
<span class="p">(</span>
  <span class="kr">String</span> <span class="nx">text</span><span class="p">,</span>
  <span class="kr">Luminance</span><span class="p">(</span><span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span> <span class="nx">image</span>
<span class="p">)</span>
</code></pre>
<blockquote>
<p>Here the MNIST labeled data set is brought into Inkling:</p>
</blockquote>
<pre class="highlight inkling"><code><span class="k">datastore</span> <span class="nx">MNIST_data</span><span class="p">(</span><span class="nx">MNIST_schema</span><span class="p">)</span>
<span class="k">copy</span> <span class="s2">"mnist-training.csv"</span> <span class="k">into</span> <span class="nx">MNIST_data</span> <span class="k">with</span> <span class="k">format</span> <span class="o">=</span> <span class="s2">"csv"</span>

 <span class="c1"># Training 'with data'</span>
<span class="k">curriculum</span> <span class="nx">digit_curriculum</span>
  <span class="k">train</span> <span class="nx">Digit</span>
  <span class="k">with</span> <span class="k">data</span>
  <span class="nx">objective_</span> <span class="nx">equality</span>  <span class="nx">training_data_</span><span class="p">,</span> <span class="nx">_test_data_</span> <span class="o">=</span> <span class="nx">split</span><span class="p">(</span><span class="nx">MNIST_data</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="nx">shuffle</span><span class="o">=</span><span class="nx">True</span><span class="p">)</span>
    <span class="c1">#lessons</span>
<span class="k">end</span>
</code></pre>
<p>In this example:</p>

<ul>
<li><strong>curriculumName:</strong> digit_curriculum</li>
<li><strong>conceptName:</strong> Digit</li>
<li><strong>trainingSpecifier:</strong> data</li>
<li><strong>objectiveName:</strong> equality</li>
<li><strong>assignment</strong>:</li>
<li><strong>training_data:</strong> variable name for subset of data portioned aside for training.</li>
<li><strong>test_data:</strong> variable name for subset of data portioned aside for testing.</li>
<li>&rsquo;<strong>=</strong>&rsquo;: represents the assignment of the result of the split function to the two variable names.</li>
<li><strong>split function:</strong> splits the data and labels it.</li>
<li><strong>MNIST_data:</strong> the data set used for training and testing.</li>
<li><strong>0.8:</strong> the amount to split the data by. 80% of the data goes to training. The remaining data (20%) goes to testing.</li>
<li><strong>shuffle=True:</strong> sets the shuffle parameter to true.</li>
</ul>

          <h2 id="lesson">Lesson</h2>

<p>Reference for the keyword <strong>lesson</strong>. Also, describes the keywords: <strong>follows</strong>, <strong>configure</strong>, <strong>constrain</strong>, <strong>until</strong>, <strong>minimize</strong>, <strong>maximize</strong>, <strong>configure</strong>, <strong>with</strong>, and <strong>end.</strong></p>

<h3 id="what-is-it">What is it?</h3>

<p>The <strong>lesson</strong> (keyword) declares an individual lesson for the concept being trained by the curriculum.  Lessons are contained within curriculum statements. A curriculum can contain multiple lessons.</p>

<h3 id="why-do-i-use-it">Why do I use it?</h3>

<p>Lessons give you control over the training of the mental model. They allow you to break down the training of the concept into phases where each phase is implemented by a lesson.</p>

<h3 id="how-do-i-use-it">How do I use it?</h3>

<blockquote>
<p>Below we show the clauses a lesson can contain.</p>
</blockquote>
<pre class="highlight inkling"><code><span class="k">lesson</span> <span class="nx">lessonName</span>
    <span class="k">follows</span> <span class="nx">prevLessonName</span>
    <span class="nx">configureClause</span>
  <span class="nx">trainClause</span>
  <span class="nx">testClause</span>
  <span class="nx">untilClause</span>
</code></pre>
<p>Lessons allow the machine to learn the concept in stages rather than all at once. In the example we show lessons that break into stages the task of  playing the game breakout. The first lesson, <code class="prettyprint">constant_breakout</code>, trains the machine with a set of fixed values as configuration parameters. The second lesson, <code class="prettyprint">vary_breakout</code>, which <strong>follows</strong> constant_breakout, trains the machine with a set of configuration parameters that vary according to specified type constraints.</p>
<pre class="highlight inkling"><code><span class="k">schema</span> <span class="nx">BreakoutConfig</span>   <span class="c1"># configured in configureClause</span>
  <span class="kr">UInt32</span> <span class="nx">level</span><span class="p">,</span>
  <span class="kr">UInt8</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">}</span> <span class="nx">paddle_width</span><span class="p">,</span>
  <span class="kr">Float32</span> <span class="nx">bricks_percent</span>
<span class="k">end</span>

<span class="k">curriculum</span> <span class="nx">ball_location_curriculum</span>
  <span class="k">train</span> <span class="nx">ball_location</span>
  <span class="k">with</span> <span class="k">simulator</span> <span class="nx">breakout_simulator</span>
  <span class="k">objective</span> <span class="nx">ball_location_distance</span>

    <span class="k">lesson</span> <span class="nx">constant_breakout</span>
      <span class="k">configure</span>           <span class="c1"># configure to constant values</span>
        <span class="k">constrain</span> <span class="nx">bricks_percent</span> <span class="k">with</span> <span class="kr">Float32</span><span class="p">{</span><span class="mf">0.5</span><span class="p">},</span>
        <span class="k">constrain</span> <span class="nx">level</span> <span class="k">with</span> <span class="kr">UInt32</span><span class="p">{</span><span class="mi">1</span><span class="p">},</span>    <span class="c1"># e.g. level = 1</span>
        <span class="k">constrain</span> <span class="nx">paddle_width</span> <span class="k">with</span> <span class="kr">UInt8</span><span class="p">{</span><span class="mi">4</span><span class="p">}</span>
      <span class="k">train</span>
        <span class="k">from</span> <span class="nx">frame</span> <span class="k">in</span> <span class="nx">breakout_simulator</span>
        <span class="k">select</span> <span class="nx">frame</span>
        <span class="k">send</span> <span class="nx">frame</span>
      <span class="k">test</span>
        <span class="k">from</span> <span class="nx">frame</span> <span class="k">in</span> <span class="nx">breakout_simulator</span>
        <span class="k">select</span> <span class="nx">frame</span>
        <span class="k">send</span> <span class="nx">frame</span>
      <span class="k">until</span>
        <span class="k">minimize</span> <span class="nx">ball_location_distance</span>

    <span class="k">lesson</span> <span class="nx">vary_breakout</span> <span class="k">follows</span> <span class="nx">constant_breakout</span>
      <span class="k">configure</span>          <span class="c1"># configure to type constraints</span>
      <span class="k">constrain</span> <span class="nx">bricks_percent</span> <span class="k">with</span> <span class="kr">Float32</span><span class="p">{</span><span class="mf">0.1</span><span class="p">:</span><span class="mf">0.01</span><span class="p">:</span><span class="mf">1.0</span><span class="p">},</span>
      <span class="k">constrain</span> <span class="nx">level</span> <span class="k">with</span> <span class="kr">UInt32</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">100</span><span class="p">},</span> <span class="c1"># e.g. level varies from 1..100</span>
      <span class="k">constrain</span> <span class="nx">paddle_width</span> <span class="k">with</span> <span class="kr">UInt8</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">}</span>
    <span class="k">train</span>
      <span class="k">from</span> <span class="nx">frame</span> <span class="k">in</span> <span class="nx">breakout_simulator</span>
      <span class="k">select</span> <span class="nx">frame</span>
      <span class="k">send</span> <span class="nx">frame</span>
    <span class="k">test</span>
      <span class="k">from</span> <span class="nx">frame</span> <span class="k">in</span> <span class="nx">breakout_simulator</span>
      <span class="k">select</span> <span class="nx">frame</span>
      <span class="k">send</span> <span class="nx">frame</span>
    <span class="k">until</span>
      <span class="k">minimize</span> <span class="nx">ball_location_distance</span>
<span class="k">end</span>
</code></pre>
<p>Lesson clauses have defaults so if a clause is not specified the default will be assumed. Also in certain circumstances not all clauses are available. (The specific rules appear in the lesson clauses table below.)</p>

<p>The two lessons above are different in their configure clause. The first sets the fields in the configuration schema to constant values and the second lesson, <code class="prettyprint">vary_breakout</code>, generates sets of values constrained by the type constraint. The syntax diagram below for <code class="prettyprint">constrainedType</code> shows the syntactic rules for type constraints.</p>

<p>Note that the <strong>constrain</strong> name in the example above specifies a field in the configuration schema for the simulator. These fields in the example are <code class="prettyprint">bricks_percent</code>, <code class="prettyprint">level</code>, and <code class="prettyprint">paddle_width</code>. When such fields are initialized with values from a type constraint they are often called placeholders.  This means that the name is is not the name of a specific value but rather it is the name of a range of values which will be input during training.</p>

<p>You can find more discussion of type constraint rules in the <a href="#schemas-inkling-types-and-type-constraints">schema</a> section. (Schema declarations can also use type constraints.)</p>

<h6 id="lesson-syntax">Lesson Syntax</h6>

<blockquote>
<p>lessonStatement :=</p>
</blockquote>
<pre class="highlight inkling"><code><span class="k">lesson</span> <span class="o">&lt;</span><span class="nx">lessonName</span><span class="o">&gt;</span>
  <span class="p">[</span><span class="k">follows</span> <span class="o">&lt;</span><span class="nx">lessonName</span><span class="o">&gt;</span><span class="p">]?</span>
  <span class="nx">configureClause</span><span class="p">?</span>
  <span class="nx">trainClause</span><span class="p">?</span>
  <span class="nx">untilClause</span><span class="p">?</span>
  <span class="nx">testClause</span><span class="p">?</span>
</code></pre>
<p>‍</p>

<h6 id="lesson-configure-clause-syntax">Lesson Configure Clause Syntax</h6>

<blockquote>
<p>configureClause :=</p>
</blockquote>
<pre class="highlight inkling"><code><span class="k">configure</span>
  <span class="p">[</span><span class="k">constrain</span> <span class="o">&lt;</span><span class="nx">configSchemaFieldName</span><span class="o">&gt;</span> <span class="k">with</span> <span class="nx">constrainedType</span><span class="p">]</span><span class="o">+</span>
</code></pre>
<blockquote>
<p>constrainedType :=</p>
</blockquote>
<pre class="highlight c"><code><span class="n">numericType</span>
<span class="sc">'{'</span>
  <span class="n">start</span> <span class="sc">':'</span> <span class="p">[</span> <span class="n">step</span><span class="sc">':'</span><span class="p">]</span><span class="o">?</span> <span class="n">stop</span> <span class="c1">// 1:2:10. Called a 'colon range'.
</span>                             <span class="c1">// Specifies 'step' (default=1).
</span><span class="o">|</span>
  <span class="n">start</span> <span class="sc">'.'</span> <span class="sc">'.'</span> <span class="n">stop</span> <span class="sc">':'</span> <span class="n">numSteps</span> <span class="c1">// 1..10:5  Called a 'dot range'.
</span>                                  <span class="c1">// Specifies 'numsteps'.
</span><span class="sc">'}'</span>
</code></pre>
<blockquote>
<p>numericType :=</p>
</blockquote>
<pre class="highlight c"><code><span class="n">Double</span> <span class="o">|</span> <span class="n">Float64</span> <span class="o">|</span> <span class="n">Float32</span> <span class="o">|</span> <span class="n">Int8</span> <span class="o">|</span> <span class="n">Int16</span> <span class="o">|</span> <span class="n">Int32</span> <span class="o">|</span>  <span class="n">Int64</span> <span class="o">|</span> <span class="n">UInt8</span> <span class="o">|</span> <span class="n">UInt16</span> <span class="o">|</span> <span class="n">UInt32</span>  <span class="o">|</span> <span class="n">UInt64</span>
</code></pre>
<p>‍</p>

<p>The testClause and the trainClause have identical syntax except for their keyword (<strong>train</strong> or <strong>test</strong>).  However they both vary depending on the trainingSpecifier in the curriculum. The <strong>expect</strong> is only available in those cases that have known expected values, and that occurs when the trainingSpecifier is <strong>data</strong> or <strong>generator</strong>.</p>

<h6 id="lesson-train-test-clause-syntax">Lesson Train/Test Clause Syntax</h6>

<blockquote>
<p>trainClause :=</p>
</blockquote>
<pre class="highlight inkling"><code><span class="k">train</span>
  <span class="nx">fromClause</span>
  <span class="k">send</span> <span class="o">&lt;</span><span class="nx">name</span><span class="o">&gt;</span>
  <span class="p">[</span><span class="k">expect</span> <span class="o">&lt;</span><span class="nx">name</span><span class="o">&gt;</span><span class="p">]?</span>    <span class="c1"># only valid for data or generator</span>
<span class="nx">trainingSpecifer</span>
</code></pre>
<blockquote>
<p>testClause :=</p>
</blockquote>
<pre class="highlight inkling"><code><span class="k">test</span>
  <span class="nx">fromClause</span>
  <span class="k">send</span> <span class="o">&lt;</span><span class="nx">name</span><span class="o">&gt;</span>
  <span class="p">[</span><span class="k">expect</span> <span class="o">&lt;</span><span class="nx">name</span><span class="o">&gt;</span><span class="p">]?</span>    <span class="c1"># only valid for data or generator</span>
<span class="nx">trainingSpecifer</span>
</code></pre>
<p>‍
The fromClause in the test/train syntax is used to name and describe the training data that is sent by the system (either from a labeled data set, in the <strong>data</strong> case, or by the generator or simulator) to the lesson.  Here is an example where the fromClause is shown in a curricululm which trains the machine to recognize line segments in an image. The generator <code class="prettyprint">segments_generator</code> sends an image and expects <code class="prettyprint">num_segments</code> in return. The returned <code class="prettyprint">num_segments</code> is expected to match the generator&rsquo;s <code class="prettyprint">num_segments</code> value.</p>
<pre class="highlight inkling"><code><span class="err">‍</span><span class="k">generator</span> <span class="nx">segments_generator</span><span class="p">(</span><span class="kr">UInt8</span> <span class="nx">segmentCount</span><span class="p">)</span>
  <span class="k">yield</span> <span class="p">(</span><span class="nx">segments_training_schema</span><span class="p">)</span>     <span class="c1"># training will yield data with this schema</span>
<span class="k">end</span>

<span class="k">schema</span> <span class="nx">segments_training_schema</span>
  <span class="kr">UInt8</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">}</span> <span class="nx">num_segments</span><span class="p">,</span>
  <span class="kr">Luminance</span><span class="p">(</span><span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span> <span class="nx">image</span>
<span class="k">end</span>

<span class="k">curriculum</span> <span class="nx">segments_curriculum</span>
  <span class="k">train</span> <span class="nx">Segments</span>
  <span class="k">with</span> <span class="k">generator</span> <span class="nx">segments_generator</span>
  <span class="k">objective</span> <span class="nx">segments_objective</span>
    <span class="k">lesson</span> <span class="nx">segments</span>
      <span class="k">configure</span>
        <span class="k">constrain</span> <span class="nx">segmentCount</span> <span class="k">with</span> <span class="kr">UInt8</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">}</span>
    <span class="k">train</span>
      <span class="k">from</span> <span class="nx">item</span> <span class="k">in</span> <span class="nx">segments_generator</span> <span class="c1"># segments_generator's yield clause</span>
        <span class="k">select</span> <span class="nx">item</span>                 <span class="c1"># specifies the appropriate schema.</span>
        <span class="k">send</span> <span class="nx">item</span><span class="p">.</span><span class="nx">image</span>             <span class="c1"># A field in segments_training_schema</span>
        <span class="k">expect</span> <span class="nx">item</span><span class="p">.</span><span class="nx">num_segments</span>    <span class="c1"># A field in segments_training_schema</span>
<span class="k">end</span>
</code></pre>
<p>‍
The <code class="prettyprint">until</code> Clause in the lesson specifies the termination condition for training. The <code class="prettyprint">until</code> Clause in our breakout example above was this:</p>
<pre class="highlight inkling"><code><span class="k">until</span>
  <span class="k">minimize</span> <span class="nx">ball_location_distance</span>
</code></pre>
<p>‍
This means train until the curriculum objective (ball_location_distance) is minimized. Here is the syntax for the <code class="prettyprint">until</code> Clause.</p>

<p>‍</p>

<h6 id="lesson-until-clause-syntax">Lesson Until Clause Syntax</h6>

<blockquote>
<p>untilClause :=</p>
</blockquote>
<pre class="highlight inkling"><code><span class="k">until</span>
  <span class="p">(</span>
    <span class="p">[</span> <span class="k">minimize</span> <span class="o">|</span> <span class="k">maximize</span> <span class="p">]</span> <span class="o">&lt;</span><span class="nx">objectiveFunctionName</span><span class="o">&gt;</span>
    <span class="o">|</span>
    <span class="o">&lt;</span><span class="nx">objectiveFunctionName</span><span class="o">&gt;</span> <span class="nx">relOp</span> <span class="nx">constantExpression</span>
  <span class="p">)</span>
</code></pre>
<blockquote>
<p>relOp :=</p>
</blockquote>
<pre class="highlight plaintext"><code>           '==' | '&lt;' | '&gt;' | '&lt;=' | '&gt;='
</code></pre>
<p>The <code class="prettyprint">until</code> Clause is only required if the curriculum trainingSpecifier is <strong>simulator</strong>.  If this curriculum has a trainingSpecifier of <strong>data</strong> or <strong>generator</strong>, the until clause is optional. If it is not present, a default with value minimize will be created.</p>

<h6 id="lesson-clauses-table">Lesson Clauses Table</h6>

<p>Lesson clauses have defaults so if a clause is not specified the default will be assumed. Also in certain circumstances not all clauses are available. This table specifies the rules. Recall that the trainingSpecifier appears after the keyword <strong>with</strong> in the curriculum.</p>

<p><img src="https://daks2k3a4ib2z.cloudfront.net/57bf257ce45825764c5cb54b/57e8edb6507ff363506fcb75_Screen%20Shot%202016-09-26%20at%2005.42.50.png" alt="57e8edb6507ff363506fcb75 screen%20shot%202016 09 26%20at%2005.42.50" /></p>

<p>Table for Lesson Clauses</p>

<h6 id="lesson-rules">Lesson Rules</h6>

<ul>
<li>To summarize the table above, for a lesson associated with a trainingSpecifier of <strong>data</strong>: one or both of the lesson clauses <strong>train</strong> and <strong>test</strong> are required (and there are no default versions of these clauses).</li>
<li>Test clause is optional for any particular lesson. However if the last lesson has no test clause it is an error.</li>
<li>The <em>follows</em> clause on the lesson is optional. <strong>Note:</strong> If there is no <em>follows</em> clause and the lessons are executed in parallel, training will be slower.</li>
<li>To summarize the table above: for a lesson associated with a trainingSpecifier of <strong>generator</strong> or <strong>simulator</strong>:

<ul>
<li>if neither the <strong>test</strong> or <strong>train</strong> lesson clauses are present, defaults for both clauses are generated. (See the above table for default details.) Otherwise, no defaults are generated.</li>
</ul></li>
<li>Lesson statements appear within curriculum statements.</li>
<li>Lesson statements may contain the following keywords: configure, train, test, and until.</li>
<li>Lessons appear after the objective clause in curriculums.</li>
<li>Lessons can be ordered, using the <strong>follows</strong> clause. Note that this ordering is a suggestion to the instructor, not a hard and fast rule.</li>
</ul>

          <h2 id="objectives">Objectives</h2>

<p>The <strong>objective</strong>, often known in machine learning (ML) as the <strong>reward function</strong>, measures how well the AI is doing at learning the concept. Or, put differently, it is what you use to reward the AI.</p>

<p>This idea may be easier to understand with a few examples:</p>

<p>In our Breakout example, our concept was get_high_score. The <strong>score</strong> is how we are measuring how well the AI is doing at learning that concept.</p>

<p>If we are teaching the AI Pacman, and we are training the concept of <code class="prettyprint">avoid_non_blue_ghosts</code>, we may measure how well the AI is doing at learning this concept by measuring the amount of time the AI manages to avoid non-blue ghosts. Our objective clause uses <strong>time</strong> as the reward.</p>

<p>In these examples, the objective, or reward, is one of the factors we use to measure how well the AI is training on the concept.</p>

<h6 id="determining-objectives">Determining Objectives</h6>

<p>There are several factors you can use to determine what your objective should be. Before you even start determining your objectives, you need to know what your concepts and curricula are. A good objective should reward the AI more often and be proportional to the quality of of the behavior.</p>

<h3 id="frequency">Frequency</h3>

<p>Frequency matters in training. The time between the AI&rsquo;s decision making and whether or not the decision was good needs to be kept short.  For example, if you&rsquo;re teaching an AI to play Pacman, you want to choose an objective like <code class="prettyprint">score</code> instead of an objective like <code class="prettyprint">level</code>.</p>

<p>In Pacman, your score changes more often, probably many times during a level, but your level can only change 256 times. Your AI would have to beat an entire level to be rewarded. The length of time between a decision the AI makes and the reward should have a higher frequency and should scale with the as the AI learns.</p>

<h3 id="proportional">Proportional</h3>

<p>The reward should be in proportional to the quality of the behavior (or the correctness of the behavior). When you are deciding what your objective is going to be, you need to consider that the AI will learn exactly what you ask it to learn. This can result in learning what you specified but not necessarily what you wanted. For example, if you ask an AI to play Pong, and you use the objective of <code class="prettyprint">time</code>, the AI will learn that to get the longest time played, the paddle should remain in the same place. The ball will bounce back and forth between the two unmoving paddles.</p>

<p>In the Pong example, the AI learned exactly what you told it to learn, how to maximize the amount of time, but it didn&rsquo;t really learn how to play the game.</p>

<p>You need to think about what training with a specific reward  will produce in terms of the quality or correctness of the behavior.</p>

<h6 id="in-inkling">In Inkling</h6>

<p>In an Inkling program, your objective is going to be part of your curriculum statement.</p>
<pre class="highlight inkling"><code><span class="k">curriculum</span> <span class="nx">_curriculumName</span>
    <span class="k">train</span> <span class="nx">_conceptName</span>
    <span class="k">with</span> <span class="nx">_trainingSpecifier</span>
  <span class="k">objective</span> <span class="nx">_objectiveName</span>
    <span class="c1"># lessons are specified here.</span>
<span class="k">end</span>
</code></pre>
          <h1 id="inkling-miscellany">Inkling Miscellany</h1>

<p>Additional resources, examples, and Inkling information can be found here.</p>

          <h2 id="example-cart-pole">Example: Cart Pole</h2>

<p>In this example, we&rsquo;ll walk you through the various statements that are part of the cart pole Inkling file. Each statement is followed by an explanation of the statement.</p>

<h6 id="what-is-cart-pole">What is Cart Pole?</h6>

<p>Cart Pole is a classic control problem. <a href="https://gym.openai.com/envs/CartPole-v1">OpenAI Gym</a> describes it as:</p>

<p><em>A pole is attached by an un-actuated joint to a cart, which moves along a frictionless track. The system is controlled by applying a force of +1 or -1 to the cart. The pendulum starts upright, and the goal is to prevent it from falling over. A reward of +1 is provided for every timestep that the pole remains upright. The episode ends when the pole is more than 15 degrees from vertical, or the cart moves more than 2.4 units from the center.</em></p>

<h6 id="schema-gamestate-action-and-cartpoleconfig">Schema: <code class="prettyprint">GameState</code>, <code class="prettyprint">Action</code>, and <code class="prettyprint">CartPoleConfig</code></h6>
<pre class="highlight inkling"><code><span class="k">schema</span> <span class="nx">GameState</span>
  <span class="kr">Float32</span> <span class="nx">position</span><span class="p">,</span>
  <span class="kr">Float32</span> <span class="nx">velocity</span><span class="p">,</span>
  <span class="kr">Float32</span> <span class="nx">angle</span><span class="p">,</span>
  <span class="kr">Float32</span> <span class="nx">rotation</span>
<span class="k">end</span>
</code></pre>
<p>The schema <code class="prettyprint">GameState</code> names four records — <code class="prettyprint">position</code>, <code class="prettyprint">velocity</code>, <code class="prettyprint">angle</code>, and <code class="prettyprint">rotation</code> — and assigns a type to them. This information is input from the simulation.</p>
<pre class="highlight inkling"><code><span class="k">schema</span> <span class="nx">Action</span>
  <span class="kr">Int8</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span> <span class="k">action</span>
<span class="k">end</span>
</code></pre>
<p>The schema <code class="prettyprint">Action</code> names a record — <code class="prettyprint">action</code> —  and assigns it a constrained type.</p>
<pre class="highlight inkling"><code><span class="k">schema</span> <span class="nx">CartPoleConfig</span>
  <span class="kr">Int8</span> <span class="nx">episode_length</span><span class="p">,</span>
  <span class="kr">Int8</span> <span class="nx">num_episodes</span><span class="p">,</span>
  <span class="kr">UInt8</span> <span class="nx">deque_size</span>
<span class="k">end</span>
</code></pre>
<p>The schema <code class="prettyprint">CartPoleConfig</code> names three records — <code class="prettyprint">episode_length</code>, <code class="prettyprint">num_episodes</code>, and <code class="prettyprint">deque_size</code> — and assigns each of them a type.</p>

<h6 id="concept-balance">Concept: <code class="prettyprint">balance</code></h6>
<pre class="highlight inkling"><code><span class="k">concept</span> <span class="nx">balance</span>
  <span class="k">is</span> <span class="nx">classifier</span>
  <span class="k">predicts</span> <span class="nx">Action</span>
  <span class="k">follows</span> <span class="kr">input</span><span class="p">(</span><span class="nx">GameState</span><span class="p">)</span>
  <span class="k">feeds</span> <span class="kr">output</span>
<span class="k">end</span>
</code></pre>
<p>The concept is named <code class="prettyprint">balance</code>, and it takes input from the simulator. That input is the records in the schema <code class="prettyprint">GameState</code>. The balance concept outputs the move the AI should make in the simulator. This output is the record in the <code class="prettyprint">Action</code> schema.</p>

<h6 id="curriculum-balance_curriculum">Curriculum: <code class="prettyprint">balance_curriculum</code></h6>
<pre class="highlight inkling"><code><span class="k">simulator</span> <span class="nx">cartpole_simulator</span><span class="p">(</span><span class="nx">CartPoleConfig</span><span class="p">)</span>
  <span class="k">state</span> <span class="p">(</span><span class="nx">GameState</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">curriculum</span> <span class="nx">balance_curriculum</span>
  <span class="k">train</span> <span class="nx">balance</span>
  <span class="k">with</span> <span class="k">simulator</span> <span class="nx">cartpole_simulator</span>
  <span class="k">objective</span> <span class="nx">up_time</span>
  <span class="k">lesson</span> <span class="nx">balancing</span>
    <span class="k">configure</span>
      <span class="k">constrain</span> <span class="nx">episode_length</span> <span class="k">with</span> <span class="kr">Int8</span><span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">}</span>
      <span class="k">constrain</span> <span class="nx">num_episodes</span> <span class="k">with</span> <span class="kr">Int8</span><span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">}</span>
      <span class="k">constrain</span> <span class="nx">deque_size</span> <span class="k">with</span> <span class="kr">UInt8</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span>
    <span class="k">until</span>
      <span class="k">maximize</span> <span class="nx">up_time</span>
<span class="k">end</span>
</code></pre>
<ul>
<li>The curriculum&rsquo;s name is balance_curriculum. It trains the balance concept with a simulator, specifically the cartpole_simulator.</li>
<li>The cartpole_simulator gets information from two schemas. The first schema, CartPoleConfig, specifies the schema for configuration of the simulation. The second schema contains the state of the simulator that is sent to the lesson.</li>
<li>The objective for this curriculum is up_time. The objective measures how long the pole stays upright.</li>
<li>This curriculum contains one lesson, called balancing. It configures the simulation, by setting a number of constraints for the state of the simulator.</li>
<li>The lesson trains until the AI has maximized the objective.</li>
</ul>

          <h2 id="example-mountain-car">Example: Mountain Car</h2>

<p>We&rsquo;ve used pieces of code from this example in several places, but here we&rsquo;ll walk you through all the various statements that are part of the mountain car Inkling file. Each statement is followed by an explanation of the statement.</p>

<p>Mountain car is a classic control problem. <a href="https://gym.openai.com/envs/MountainCar-v0">OpenAI Gym</a> describes it as:</p>

<p><em>A car is on a one-dimensional track, positioned between two &ldquo;mountains&rdquo;. The goal is to drive up the mountain on the right; however, the car&rsquo;s engine is not strong enough to scale the mountain in a single pass. Therefore, the only way to succeed is to drive back and forth to build up momentum.</em></p>

<h6 id="schema-gamestate-action-mountaincarconfig">Schema: <code class="prettyprint">GameState</code>, <code class="prettyprint">Action</code>, <code class="prettyprint">MountainCarConfig</code></h6>
<pre class="highlight inkling"><code><span class="k">schema</span> <span class="nx">GameState</span>
   <span class="kr">Float32</span> <span class="nx">x_position</span><span class="p">,</span>
   <span class="kr">Float32</span> <span class="nx">y_velocity</span>
<span class="k">end</span>
</code></pre>
<p>The GameState schema names two records — <code class="prettyprint">x_position</code> and <code class="prettyprint">y_position</code> — and assigns a type to them.</p>
<pre class="highlight inkling"><code><span class="k">schema</span> <span class="nx">Action</span>
  <span class="kr">Int8</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">}</span> <span class="k">action</span>
<span class="k">end</span>
</code></pre>
<p>The Action schema names a single record — <code class="prettyprint">action</code> — and assigns a constrained type to it.</p>
<pre class="highlight inkling"><code><span class="k">schema</span> <span class="nx">MountainCarConfig</span>
  <span class="kr">Int8</span> <span class="nx">episode_legnth</span><span class="p">,</span>
  <span class="kr">Int8</span> <span class="nx">num_episodes</span><span class="p">,</span>
  <span class="kr">UInt8</span> <span class="nx">deque_size</span>
<span class="k">end</span>
</code></pre>
<p>The <code class="prettyprint">MountainCarConfig</code> schema names three records — <code class="prettyprint">episode_length</code>, <code class="prettyprint">num_episodes</code>, and <code class="prettyprint">deque_size</code> — and assigns types to them.</p>

<h6 id="concept-high_score">Concept <code class="prettyprint">high_score</code></h6>
<pre class="highlight inkling"><code><span class="k">concept</span> <span class="nx">high_score</span>
  <span class="k">is</span> <span class="nx">classifier</span>
  <span class="k">predicts</span> <span class="nx">Action</span>
  <span class="k">follows</span> <span class="kr">input</span><span class="p">(</span><span class="nx">GameState</span><span class="p">)</span>
  <span class="k">feeds</span> <span class="kr">output</span>
<span class="k">end</span>
</code></pre>
<p>The concept is named <code class="prettyprint">high_score</code>, and it takes input from the simulator about the state of the game (<code class="prettyprint">GameState</code> schema). It outputs to the <code class="prettyprint">Action</code> schema. This is the AI&rsquo;s next move in the game.</p>

<h6 id="curriculum-high_score_curriculum">Curriculum: <code class="prettyprint">high_score_curriculum</code></h6>
<pre class="highlight inkling"><code><span class="k">simulator</span> <span class="nx">mountaincar_simulator</span><span class="p">(</span><span class="nx">MountainCarConfig</span><span class="p">)</span>
  <span class="k">state</span>  <span class="p">(</span><span class="nx">GameState</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">curriculum</span> <span class="nx">high_score_curriculum</span>
  <span class="k">train</span> <span class="nx">high_score</span>
  <span class="k">with</span> <span class="k">simulator</span> <span class="nx">mountaincar_simulator</span>
  <span class="k">objective</span> <span class="nx">score</span>
  <span class="k">lesson</span> <span class="nx">get_high_score</span>
    <span class="k">configure</span>
      <span class="k">constrain</span> <span class="nx">episode_length</span> <span class="k">with</span> <span class="kr">Int8</span><span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">},</span>
      <span class="k">constrain</span> <span class="nx">num_episodes</span> <span class="k">with</span> <span class="kr">Int8</span><span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">},</span>
      <span class="k">constrain</span> <span class="nx">deque_size</span> <span class="k">with</span> <span class="kr">UInt8</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span>
    <span class="k">until</span>
      <span class="k">maximize</span> <span class="nx">score</span>
<span class="k">end</span>
</code></pre>
<ul>
<li>The curriculum is named high_score_curriculum, and it trains the high_score concept using the mountaincar_simulator.</li>
<li>The mountain_car simulator gets information from two schemas. The first (<code class="prettyprint">MountainCarConfig</code>) specifies the schema for configuration of the simulation. The second schema contains the state of the simulator that is sent to the lesson.</li>
<li>This curriculum contains one lesson, called <code class="prettyprint">get_high_score</code>. It configures the simulation, by setting a number of constraints for the state of the simulator.</li>
<li>The lesson trains until the AI has maximized the objective.</li>
</ul>

          <h2 id="under-the-hood">Under the Hood</h2>

<p>This section describes some of how Bonsai AI&rsquo;s engine works under the hood using Inkling to teach BRAINs.</p>

<h6 id="major-components">Major components</h6>

<p>Bonsai&rsquo;s AI Engine has several major components.</p>

<ul>
<li><strong>The architect</strong> :generates learning models using the Inkling program and characteristics of the provided training content.</li>
<li><strong>The instructor:</strong> trains those topologies according to the information set out in the Inkling program</li>
<li><strong>The learner:</strong> does the learning, and <strong>the predictor</strong> predicts.</li>
<li>There are many other parts of our system that are more common—systems for storing and querying data, systems for streaming and manipulating data, and plumbing to expose models in the AI engine as API&rsquo;s</li>
</ul>

<h3 id="architect">Architect</h3>

<p>The architect component is responsible for creating and optimizing learning topologies (e.g. neural networks) based on mental models. In essence, it takes the codified mental model and pedagogy, and it proposes a set of candidate low level learning algorithms, topologies, and their configurations that it believes will best be able to learn the concepts in the model.  This is akin to the work that the data scientist does in the toolkit approach, or that the search system automates in the statistical data analysis tools approach. Here, the system, is guided by the provided pedagogical program instead of being a broad search.</p>

<h3 id="instructor">Instructor</h3>

<p>The instructor component is responsible for carrying out the training plan codified in the pedagogy. To do so, it must form internal representations about the capability level of each concept, and adapt the execution plan based on actual performance during training. While some operations can take place in a traditional, batch oriented fashion, the system is designed to work in an interactive streaming fashion wherein the system being trained is presented with data or an environment, asked to compute its output or action, has its performance assessed, and is then asked to learn accordingly.  This streaming approach allows intermixing data oriented and simulation oriented training approaches.</p>

<h3 id="learner">Learner</h3>

<p>The learner component is responsible for carrying out the actual execution of the low level, underlying artificial intelligence algorithms. In training mode, it instantiates a system conforming to what was proposed by the architect, interfaces with the instructor to set the parameters of the learning algorithm, and assess performance. Then, it executes the learning algorithm itself. In execution mode, it will instantiate an instance of the already trained system, and execute its computation when called for.</p>

<h3 id="transformer">Transformer</h3>

<p>The transformer carries out any streaming data transformations that do not require learning. When authors create BRAIN models, some concepts do not require learning; code specifying explicitly how to calculate them can be specified. For example, if you want to use the concept of a moving average.  Rather than have the system learn how to calculate a moving average, you can easily specify how to calculate it explicitly. Such transformations take the form of &ldquo;stream&rdquo; statements in Inkling, which will be described in more detail below.  The transformer carries out the actual execution of such transformations when needed.</p>

<h3 id="predictor">Predictor</h3>

<p>After an algorithm is trained, it is hosted in a &lsquo;prediction mode&rsquo;. This mode holds a neural network for use as an HTTP API endpoint.  The programmer can then send input data to the predictor and get back a prediction.</p>

<h2 id="versioning">Versioning</h2>

<p>The Bonsai AI Engine keeps versions of BRAINs. Each load operation and training session generates a new version. This way you can compare the latest version of a BRAIN with previous versions.</p>

<h6 id="the-architect">The Architect</h6>

<p>The architect component is responsible for creating and optimizing learning topologies (e.g. neural networks) based on mental models. In this section, we outline techniques used by the architect to determine reasonable architectures.</p>

<h3 id="heuristics">Heuristics</h3>

<p>First, many heuristics regarding the mental model can be used to inform what types of artificial intelligence and machine learning algorithms to use.  For example, the data types used have a large influence. For this reason, Inkling contains rich native data types in addition to the basic data types. If the architect sees, for example, that an image is being used, a convolutional deep learning neural network architecture may be appropriate.  If the architect sees data that is temporal in nature (for example audio data, or sequence data), then a recursive deep learning neural network architecture like an LSTM network may be more appropriate. The collection of heuristics is generated by data science and machine learning / AI experts who work on the architect codebase, and who attempt to capture the heuristics that they themselves use in practice.</p>

<h3 id="mental-model-signatures">Mental Model Signatures</h3>

<p>The system also calculates a signature for a mental model. These signatures are a form of hashing such that mental models that have similar characteristics have similar signatures. These signatures can then be used in conjunction with heuristics and meta learning.</p>

<h3 id="statistical-distribution-inference">Statistical Distribution Inference</h3>

<p>In addition to looking at the mental model, the Architect also considers the pedagogy provided in the Inkling code.  It will, for example, look at the statistical distribution of any data sets being used; in the case of simulators, it can ask the simulator to generate substantial amounts of data so as to determine the statistics of data that will be used during training. These distribution properties can further inform the heuristics used.</p>

<h3 id="meta-learning">Meta Learning</h3>

<p>Meta learning is an advanced technique used by the architect.  It is, as the name implies, learning about learning.  This means, as the architect generates candidate algorithm choices and topologies for training, it records this data along with the signature of the model and the resultant system performance.  This data set is then used in its own learning system (a portion of the architect is itself written in Inkling).  Thus the architect, by virtue of proposing, exploring, and optimizing learning models, can observe what works and what doesn&rsquo;t, and use that to learn what models it should try in the future when it sees similar signatures.</p>

<h3 id="advanced-usage">Advanced Usage</h3>

<p>For advanced users, low level details of a learning topology can be explicitly specified in part or in completely.  The architect treats any such pinning of parameters as an override on its default behavior.  In this way, specific algorithms can be provided, or a generated model can be pinned for manual refinement.</p>

<h6 id="the-instructor">The Instructor</h6>

<p>The instructor component is responsible for carrying out the training plan codified in the pedagogy.  In this section, we outline techniques used by the instructor.</p>

<h3 id="the-execution-plan">The Execution Plan</h3>

<p>When starting a training operation, the instructor first generates an execution plan. It uses this ordering when teaching the concepts, and for each concept which lessons it intends to teach in what order. While the execution plan is executing, the instructor may jump back and forth between concepts and lessons to optimize training. The major techniques used to determine when to switch between lessons and concepts for training are reinforcement learning and adaptive learning.</p>

<h6 id="the-idk-and-learning-engines">The IDK and learning engines</h6>

<p>The learning engine encodes the underlying detail needed to work with a particular artificial intelligence or machine learning algorithm. The BRAIN server provides many standard learning engines such as those used for deep learning. However, learning algorithm authors can provide their own backends if so desired. By architecting the BRAIN server in this way, Inkling code gains another level of abstraction from a particular approach. If a new learning algorithm is created that has superior performance to existing algorithms, all that need be added is a new backend. The architect will immediately start using the backend to build systems, and existing Inkling programs can be recompiled without modification to take advantage of the improved algorithms.</p>

          <h2 id="import">Import</h2>

<p>Reference for the keyword <strong>import</strong>. Also, describes the keywords: <strong>from</strong></p>

<p>Note: Currently, the only function you can import is <strong>split</strong>.</p>

<h3 id="what-is-it">What is it?</h3>

<p><strong>import</strong> (the keyword) describes the usage and location of functions that are part of external libraries.</p>

<h3 id="why-do-i-use-it">Why do I use it?</h3>

<p><strong>import</strong> is used to specify the location and usage external libraries. You specify libraries that you want to use in conjunction with your Inkling code.</p>

<h3 id="how-do-i-use-it">How do I use it?</h3>

<p>Typical import statements:</p>
<pre class="highlight inkling"><code><span class="k">from</span> <span class="nx">libraryName</span> <span class="k">import</span> <span class="nx">importName1</span>
<span class="k">import</span> <span class="nx">importName2</span>
</code></pre>
<h6 id="examples">Examples</h6>
<pre class="highlight inkling"><code><span class="k">from</span> <span class="nx">utils</span> <span class="k">import</span> <span class="nx">split</span>

  <span class="k">datastore</span> <span class="nx">MNIST_data</span><span class="p">(</span><span class="nx">MNIST_training_data_schema</span><span class="p">)</span>
  <span class="k">copy</span> <span class="nx">mnist</span><span class="o">-</span><span class="nx">training</span><span class="p">.</span><span class="nx">csv</span> <span class="k">into</span> <span class="nx">MNIST_data</span> <span class="k">with</span> <span class="k">format</span><span class="o">=</span><span class="p">'</span><span class="nx">csv</span><span class="p">'</span>
</code></pre>
<blockquote>
<p>prepare the data with imported function split</p>
</blockquote>
<pre class="highlight inkling"><code><span class="nx">training_data</span><span class="p">,</span> <span class="nx">test_data</span> <span class="o">=</span> <span class="nx">split</span><span class="p">(</span><span class="nx">MNIST_data</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="nx">shuffle</span><span class="o">=</span><span class="nx">True</span><span class="p">)</span>
</code></pre>
      </div>
      <div class="dark-box">
      </div>
    </div>

    </div>

  </div>

  </body>
</html>
