


<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Inkling Reference - Bonsai</title>
    <style>
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight .gh {
  color: #999999;
}
.highlight .sr {
  color: #f6aa11;
}
.highlight .go {
  color: #888888;
}
.highlight .gp {
  color: #555555;
}
.highlight .gs {
}
.highlight .gu {
  color: #aaaaaa;
}
.highlight .nb {
  color: #f6aa11;
}
.highlight .cm {
  color: #75715e;
}
.highlight .cp {
  color: #75715e;
}
.highlight .c1 {
  color: #75715e;
}
.highlight .cs {
  color: #75715e;
}
.highlight .c, .highlight .cd {
  color: #75715e;
}
.highlight .err {
  color: #960050;
}
.highlight .gr {
  color: #960050;
}
.highlight .gt {
  color: #960050;
}
.highlight .gd {
  color: #49483e;
}
.highlight .gi {
  color: #49483e;
}
.highlight .ge {
  color: #49483e;
}
.highlight .kc {
  color: #66d9ef;
}
.highlight .kd {
  color: #66d9ef;
}
.highlight .kr {
  color: #66d9ef;
}
.highlight .no {
  color: #66d9ef;
}
.highlight .kt {
  color: #66d9ef;
}
.highlight .mf {
  color: #ae81ff;
}
.highlight .mh {
  color: #ae81ff;
}
.highlight .il {
  color: #ae81ff;
}
.highlight .mi {
  color: #ae81ff;
}
.highlight .mo {
  color: #ae81ff;
}
.highlight .m, .highlight .mb, .highlight .mx {
  color: #ae81ff;
}
.highlight .sc {
  color: #ae81ff;
}
.highlight .se {
  color: #ae81ff;
}
.highlight .ss {
  color: #ae81ff;
}
.highlight .sd {
  color: #e6db74;
}
.highlight .s2 {
  color: #e6db74;
}
.highlight .sb {
  color: #e6db74;
}
.highlight .sh {
  color: #e6db74;
}
.highlight .si {
  color: #e6db74;
}
.highlight .sx {
  color: #e6db74;
}
.highlight .s1 {
  color: #e6db74;
}
.highlight .s {
  color: #e6db74;
}
.highlight .na {
  color: #a6e22e;
}
.highlight .nc {
  color: #a6e22e;
}
.highlight .nd {
  color: #a6e22e;
}
.highlight .ne {
  color: #a6e22e;
}
.highlight .nf {
  color: #a6e22e;
}
.highlight .vc {
  color: #ffffff;
}
.highlight .nn {
  color: #ffffff;
}
.highlight .nl {
  color: #ffffff;
}
.highlight .ni {
  color: #ffffff;
}
.highlight .bp {
  color: #ffffff;
}
.highlight .vg {
  color: #ffffff;
}
.highlight .vi {
  color: #ffffff;
}
.highlight .nv {
  color: #ffffff;
}
.highlight .w {
  color: #ffffff;
}
.highlight {
  color: #ffffff;
}
.highlight .n, .highlight .py, .highlight .nx {
  color: #ffffff;
}
.highlight .ow {
  color: #f92672;
}
.highlight .nt {
  color: #f92672;
}
.highlight .k, .highlight .kv {
  color: #f92672;
}
.highlight .kn {
  color: #f92672;
}
.highlight .kp {
  color: #f92672;
}
.highlight .o {
  color: #f92672;
}
    </style>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.css" />
    <link href="../stylesheets/screen.css" rel="stylesheet" media="screen" />
    <link href="../stylesheets/print.css" rel="stylesheet" media="print" />
	  <link href="../stylesheets/test.css" rel="stylesheet" media="screen" />
    <link href="../favicon.ico" rel="icon" type="image/ico" />
      <script src="../javascripts/all.js"></script>
	
	  <!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-WVB6MG2');</script>
<!-- End Google Tag Manager -->
  </head>

  <body class="references references_inkling-reference" data-languages="[&quot;inkling--code&quot;,&quot;inkling--syntax&quot;]">
	  
	  
	  <!-- Google Tag Manager (noscript) -->
<noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-WVB6MG2"
height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
<!-- End Google Tag Manager (noscript) --> 

  <div id="flex-container">

	<nav id="primary-nav">



	<div id="logo"> <a href="../"><img class="bonsai-logo" src="../images/bonsai-logo.svg"></a></div>

	<label for="drop" class="toggle"><img class="menu-ham" src="../images/menu.svg"></label>
	<input type="checkbox" id="drop" />

	<ul class="menu">

		<li class="header_menu_item "> <a href="../guides/getting-started.html">Quick Start</a></li>

	
		<li class="header_menu_item"> <!-- First Tier Drop Down --> <label for="drop-1" class="toggle">Guides +</label><a  href="#">Guides</a>			
			<input type="checkbox" id="drop-1"/>
			<ul id="guides">
				<li class=""> <a href="../guides/ai-engine-guide.html">AI Engine Guide</a>  </li>
				<li class=""> <a href="../guides/cli-guide.html">CLI Guide</a>  </li>
				<li class=""> <a href="../guides/inkling-guide.html">Inkling Guide</a>  </li>
			</ul> 
		</li>

		<li class="header_menu_item"> <!-- First Tier Drop Down --> <label for="drop-2" class="toggle">References +</label><a  href="#">References</a>			
			<input type="checkbox" id="drop-2"/>
			<ul id="references">
				<li class=""> <a href="api-reference.html">API</a>  </li>
				<li class=""> <a href="cli-reference.html">CLI</a>  </li>
				<li class="selected"> <a href="inkling-reference.html">Inkling</a>  </li>
				<li class=""> <a href="library-reference.html">Library</a>  </li>
			</ul> 
		</li>
		
		<li class="header_menu_item "> <a href="../examples.html">Examples</a></li>

		<li>
			<input type="search" id="docs-search" placeholder="Search Bonsai Docs">
		</li>


	</ul>

</nav>





	<div id="main-wrapper">

    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="../images/navbar.png" alt="Navbar" />
      </span>
    </a>
    <div class="tocify-wrapper">

        <div class="lang-selector">
              <a href="#" data-language-name="inkling--code">Inkling</a>
              <a href="#" data-language-name="inkling--syntax">Syntax</a>
        </div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <div class="page-title">Inkling Reference</div>
      <div id="toc">
      </div>
      
			 
<ul class="toc-footer">


<li><a href='https://github.com/BonsaiAI/slate'>Contribute to the Docs</a></li>
<li><a href='http://pages.bons.ai/apply.html'>Apply for Bonsai Platform Preview</a></li>
<li><a href='http://forums.bons.ai/'>Bonsai Forums</a></li>
<li><a href='https://bons.ai/contact-us#contact-page-form'>Contact Us</a></li>
<li><a href='https://bons.ai'>Bonsai Home</a></li>

</ul>
       
        
	   <div class="cc-bottom">
	
	<div class="toc-footer bottom cc-info">

		<a href='https://creativecommons.org/licenses/by-sa/4.0/' class="cc-icon-width" >
			<svg class="cc" version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"
			viewBox="0 0 70.7 13.4" style="enable-background:new 0 0 70.7 13.4;" xml:space="preserve">

				<g>

				<g>
				<circle class="st0" cx="6.8" cy="6.7" r="6.1"/>
				<path d="M6.7,0c1.9,0,3.5,0.7,4.8,2c0.6,0.6,1.1,1.4,1.4,2.2c0.3,0.8,0.5,1.7,0.5,2.6c0,0.9-0.2,1.8-0.5,2.6
				c-0.3,0.8-0.8,1.5-1.4,2.1c-0.7,0.6-1.4,1.1-2.2,1.5c-0.8,0.3-1.7,0.5-2.6,0.5S5,13.3,4.2,12.9c-0.8-0.3-1.5-0.8-2.2-1.5
				s-1.1-1.4-1.5-2.2S0,7.6,0,6.7C0,5.8,0.2,5,0.5,4.2S1.3,2.6,2,2C3.3,0.7,4.8,0,6.7,0z M6.7,1.2c-1.5,0-2.8,0.5-3.9,1.6
				C2.3,3.4,1.9,4,1.6,4.6C1.4,5.3,1.2,6,1.2,6.7c0,0.7,0.1,1.4,0.4,2.1c0.3,0.7,0.7,1.3,1.2,1.8c0.5,0.5,1.1,0.9,1.8,1.2
				c0.7,0.3,1.4,0.4,2.1,0.4c0.7,0,1.4-0.1,2.1-0.4c0.7-0.3,1.3-0.7,1.8-1.2c1-1,1.6-2.3,1.6-3.9c0-0.7-0.1-1.4-0.4-2.1
				c-0.3-0.7-0.7-1.3-1.2-1.8C9.5,1.8,8.2,1.2,6.7,1.2z M6.6,5.6L5.7,6.1C5.6,5.9,5.5,5.7,5.4,5.6C5.3,5.6,5.1,5.5,5,5.5
				c-0.6,0-0.9,0.4-0.9,1.2c0,0.4,0.1,0.6,0.2,0.9C4.5,7.8,4.7,7.9,5,7.9c0.4,0,0.7-0.2,0.8-0.6l0.8,0.4C6.5,8.1,6.2,8.3,5.9,8.5
				c-0.3,0.2-0.7,0.3-1,0.3c-0.6,0-1.1-0.2-1.5-0.6C3.1,7.9,2.9,7.4,2.9,6.7c0-0.6,0.2-1.1,0.6-1.5c0.4-0.4,0.8-0.6,1.4-0.6
				C5.7,4.6,6.3,5,6.6,5.6z M10.5,5.6L9.6,6.1C9.5,5.9,9.4,5.7,9.3,5.6C9.1,5.6,9,5.5,8.9,5.5C8.3,5.5,8,5.9,8,6.7
				c0,0.4,0.1,0.6,0.2,0.9c0.2,0.2,0.4,0.3,0.7,0.3c0.4,0,0.7-0.2,0.8-0.6l0.8,0.4c-0.2,0.3-0.4,0.6-0.7,0.8c-0.3,0.2-0.7,0.3-1,0.3
				c-0.6,0-1.1-0.2-1.5-0.6C7,7.9,6.8,7.4,6.8,6.7c0-0.6,0.2-1.1,0.6-1.5c0.4-0.4,0.8-0.6,1.4-0.6C9.6,4.6,10.2,5,10.5,5.6z"/>
				</g>

				</g>
			</svg>
		</a>
		
		<a href='https://creativecommons.org/licenses/by-sa/4.0/'>Content:
		CC-BY-SA </a>
		
	</div>

</div>

    </div>
	      
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        
          <h1 id="inkling-overview">Inkling Overview</h1>
<pre class="highlight inkling tab-inkling--code"><code><span class="c1">#############################################</span>
<span class="c1"># Inkling Code Snippets will be shown here  #</span>
<span class="c1"># Click the "Syntax" tab for Inkling Syntax #</span>
<span class="c1">#############################################</span>
</code></pre><pre class="highlight inkling tab-inkling--syntax"><code><span class="c1">#####################################################</span>
<span class="c1"># Inkling Syntax will be shown here                 #</span>
<span class="c1"># Click the "Inkling" tab for Inkling Code Snippets #</span>
<span class="c1">#####################################################</span>
</code></pre>
<p>This reference contains comprehensive specifications and usage for the Inkling language, Bonsai’s special purpose programming language for training AI.</p>

<p>Inkling is a declarative, strongly typed language that provides a layer of
abstraction between the Inkling programmer and the vast and dynamic set of AI
algorithms that require expertise in machine learning. Inkling allows you to
focus at a conceptual level on what you want the machine to learn. That is why this model of
programming is called pedalogical programming. </p>

<p>An Inkling file contains the concepts (what you want to teach the AI), and curriculum (how you want to teach the concepts) necessary to train your BRAIN.</p>

          <h1 id="lexical-structure">Lexical Structure</h1>

<p>Reference for the lexical structure of the Inkling language.</p>

<h3 id="what-is-it">What is it?</h3>

<p>The lexical structure of Inkling includes these lexical elements:</p>

<ul>
<li><code class="prettyprint">comment</code>: specifies comment format.</li>
<li><code class="prettyprint">keyword</code>: the keyword set consists of the words that Inkling reserves for its own use.</li>
<li><code class="prettyprint">identifier</code>: user defined names in Inkling. For example, concept names.</li>
<li><code class="prettyprint">literal</code>: Inkling supports numeric and string literals.</li>
<li><code class="prettyprint">operator</code>: Inkling supports operators such as math operators and grouping operators.</li>
</ul>

<h2 id="comments">Comments</h2>

<ul>
<li>An Inkling comment begins after the character <strong>#</strong> and extends to the end of the line.</li>
</ul>
<pre class="highlight inkling tab-inkling--code"><code>  <span class="c1"># this is a comment</span>
</code></pre>
<h2 id="keywords">Keywords</h2>

<p>Here is the set of keywords in the Inkling language. These words are reserved
for use by Inkling and cannot be used as names in your program. </p>

<p><strong>Keywords Table</strong></p>

<table><thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead><tbody>
<tr>
<td>action</td>
<td>and</td>
<td>as</td>
<td>Bool</td>
<td>Byte</td>
</tr>
<tr>
<td>concept</td>
<td>configure</td>
<td>constrain</td>
<td>copy</td>
<td>curriculum</td>
</tr>
<tr>
<td>data</td>
<td>datastore</td>
<td>debug</td>
<td>Double</td>
<td>easy</td>
</tr>
<tr>
<td>end</td>
<td>expect</td>
<td>false</td>
<td>feeds</td>
<td>Float32</td>
</tr>
<tr>
<td>Float64</td>
<td>follows</td>
<td>format</td>
<td>from</td>
<td>generator</td>
</tr>
<tr>
<td>hard</td>
<td>import</td>
<td>in</td>
<td>input</td>
<td>Int16</td>
</tr>
<tr>
<td>Int32</td>
<td>Int64</td>
<td>Int8</td>
<td>into</td>
<td>is</td>
</tr>
<tr>
<td>lesson</td>
<td>let</td>
<td>Luminance</td>
<td>Matrix</td>
<td>maximize</td>
</tr>
<tr>
<td>medium</td>
<td>minimize</td>
<td>not</td>
<td>objective</td>
<td>or</td>
</tr>
<tr>
<td>output</td>
<td>predicts</td>
<td>schema</td>
<td>select</td>
<td>send</td>
</tr>
<tr>
<td>simulator</td>
<td>state</td>
<td>stream</td>
<td>String</td>
<td>test</td>
</tr>
<tr>
<td>train</td>
<td>true</td>
<td>UInt16</td>
<td>UInt32</td>
<td>UInt64</td>
</tr>
<tr>
<td>UInt8</td>
<td>unit</td>
<td>until</td>
<td>using</td>
<td>validate</td>
</tr>
<tr>
<td>where</td>
<td>with</td>
<td>yield</td>
<td></td>
<td></td>
</tr>
</tbody></table>

<h2 id="identifiers">Identifiers</h2>

<p>An Inkling identifier (user defined name) must begin with an underscore or
letter, followed by any combination of alphanumeric characters and underscore.</p>

<h2 id="literals">Literals</h2>

<p>Inkling supports numeric literals (floating point and integer) as well as string
literals. </p>

<ul>
<li><strong>String Literals</strong></li>
</ul>

<p>String literals are enclosed in double quotes. </p>

<ul>
<li><strong>Integer Literals</strong></li>
</ul>

<p>Integer literals are a string of digits with an optional sign and no decimal
point.</p>

<ul>
<li><strong>Floating Point Literals</strong></li>
</ul>

<p>Floating point literals can be Float32 or Float64 (double). Select the Inkling
tab to see some floating point literals: </p>
<pre class="highlight inkling tab-inkling--code"><code> <span class="mf">12.0</span><span class="p">,</span> <span class="p">.</span><span class="mi">5</span>        <span class="c1"># Float32 floating point literal</span>
 <span class="mi">1</span><span class="nx">e7</span><span class="p">,</span> <span class="mi">9</span><span class="nx">e0</span>        <span class="c1"># Float64 (double) floating point literal</span>
 <span class="mf">13.0f</span><span class="mi">7</span><span class="p">,</span> <span class="p">.</span><span class="mi">3</span><span class="nx">f</span><span class="o">+</span><span class="mi">2</span>   <span class="c1"># Float32 floating point literal</span>
</code></pre>
<h2 id="operators">Operators</h2>

<p>The operator category includes mathematical, relational, and logical operators as well as
paired grouping operators like <code class="prettyprint">{</code> and <code class="prettyprint">}</code>. </p>

<p><strong>Operators Table</strong></p>

<table><thead>
<tr>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
<th></th>
</tr>
</thead><tbody>
<tr>
<td>&lt;=</td>
<td>&lt;</td>
<td>==</td>
<td>=&gt;</td>
<td>=</td>
<td>&gt;=</td>
</tr>
<tr>
<td>-</td>
<td>,</td>
<td>:</td>
<td>!=</td>
<td>/</td>
<td>..</td>
</tr>
<tr>
<td>(</td>
<td>)</td>
<td>[</td>
<td>]</td>
<td>{</td>
<td>}</td>
</tr>
<tr>
<td>+</td>
<td>and</td>
<td>not</td>
<td>or</td>
<td></td>
<td></td>
</tr>
</tbody></table>

          <h1 id="concept">Concept</h1>

<p>Reference for the keyword <strong>concept</strong>. Also, describes the keywords: <strong>predicts</strong>, <strong>input</strong>, <strong>output</strong>, <strong>is</strong>, <strong>follows</strong>, <strong>end</strong>, and <strong>feeds</strong>.</p>

<h3 id="what-is-it">What is it?</h3>

<ul>
<li><code class="prettyprint">concept</code>: (the keyword) declares an abstract concept for the system to learn.</li>
<li><code class="prettyprint">is</code>: specifies the kind of prediction the trained concept will produce (<strong>classifier</strong> or <strong>estimator</strong>).</li>
<li><code class="prettyprint">predicts</code>: declares the concept&rsquo;s output.</li>
<li><code class="prettyprint">follows</code>: declares the concepts or streams the concept gets input from.</li>
<li><code class="prettyprint">feeds</code>: declares the list of concepts and streams that have this concept&rsquo;s output as input.</li>
<li><code class="prettyprint">end</code>: delimiter that declares the end of this statement.</li>
</ul>

<h3 id="why-do-i-use-it">Why do I use it?</h3>

<p>A concept statement describes what the computer will learn. It can be a feature (such as a curvy line in an image) or a goal (such as high score in a game).</p>

<h3 id="how-do-i-use-it">How Do I Use It?</h3>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">concept</span> <span class="nx">conceptName</span>
  <span class="k">is</span> <span class="nx">classifier</span>                 <span class="c1"># or 'is estimator'</span>
  <span class="k">predicts</span> <span class="p">(</span><span class="nx">outputSchema</span><span class="p">)</span>
  <span class="k">follows</span> <span class="nx">preceedingConcept1</span><span class="p">,</span> <span class="kr">input</span><span class="p">(</span><span class="nx">schemaName</span><span class="p">)</span>
  <span class="k">feeds</span> <span class="kr">output</span><span class="p">,</span> <span class="nx">subsequentconcept</span>
<span class="k">end</span>
</code></pre>
<p>If you selet the Inkling tab a typical concept statement will be shown. Its structure and keywords
are explained in the following sections.</p>

<h2 id="concept-rules">Concept Rules</h2>

<ul>
<li>The concept must be named after the <code class="prettyprint">concept</code> keyword.</li>
<li>The <code class="prettyprint">is</code> keyword specifies the kind of prediction the trained concept will produce. For example, a concept can specify is classifier. This means that the trained concept will categorize its input. Email, for example, can be classified as spam or not spam. Another option with this keyword is estimator.</li>
<li>The concept must declare an output schema after <code class="prettyprint">predicts</code>. The output schema describes the data produced by the trained concept. For example if this concept classifies email into spam and not spam, the output schema for the concept would be a Bool. The output schema can be a named schema, where the name refers to a full schema definition elsewhere, or it can be anonymous, which is a parenthesized list of name, type pairs. See the section on schema declarations for more information.</li>
<li>A trained concept gets input from streams or (if multiple concepts are used) from another concept. <code class="prettyprint">input</code> (the keyword) refers to the stream that is the original input to the system. All data flowing through the system has a schema associated with it. In some cases this is calculated rather than explicit.</li>
<li>If the <code class="prettyprint">input</code> keyword appears in the <code class="prettyprint">follows</code> list, it means that the input stream flowing into this concept comes from outside the BRAIN. The <code class="prettyprint">input</code> keyword must always be accompanied by a schema (named or anonymous) because the data stream originates outside the BRAIN; if no schema was present, data types and formats being input would be unknown.</li>
<li>The <code class="prettyprint">feeds</code> list is a list of concepts and streams (including the predefined output stream) for which this concept&rsquo;s output is a source.</li>
<li>The <code class="prettyprint">input</code> keyword cannot not appear in the feeds list and the <code class="prettyprint">output</code> keyword cannot appear in the follows list.</li>
<li>The concept statement is terminated by the <code class="prettyprint">end</code> keyword.</li>
</ul>

<h2 id="concept-statement-syntax">Concept Statement Syntax</h2>
<pre class="highlight inkling tab-inkling--syntax"><code><span class="nx">conceptStatement</span> <span class="p">:</span><span class="o">=</span>
<span class="k">concept</span>
  <span class="k">is</span> <span class="p">[</span> <span class="nx">classifier</span> <span class="o">|</span> <span class="nx">estimator</span> <span class="p">]</span>
  <span class="k">predicts</span> <span class="p">(</span> <span class="nx">schemaRef</span> <span class="p">)</span>
  <span class="p">[</span>
    <span class="k">follows</span>
      <span class="nx">inputSource</span> <span class="p">[','</span> <span class="nx">inputSource</span> <span class="p">]</span><span class="o">*</span>
    <span class="p">]?</span>
  <span class="p">[</span>
    <span class="k">feeds</span>
      <span class="nx">outputTarget</span> <span class="p">[','</span> <span class="nx">outputTarget</span> <span class="p">]</span><span class="o">*</span>

  <span class="p">]?</span>
<span class="k">end</span>

<span class="nx">inputSource</span> <span class="p">::</span><span class="o">=</span>
    <span class="kr">input</span> <span class="p">'('</span> <span class="nx">schemaRef</span><span class="p">?</span> <span class="p">')'</span>
  <span class="o">|</span> <span class="o">&lt;</span><span class="nx">name</span><span class="o">&gt;</span>       <span class="c1"># name of a concept or stream</span>

<span class="nx">outputTarget</span> <span class="p">::</span><span class="o">=</span>
    <span class="kr">output</span>
 <span class="o">|</span>  <span class="o">&lt;</span><span class="nx">name</span><span class="o">&gt;</span>       <span class="c1"># name of a concept or stream</span>
</code></pre>
<p>Select the Syntax tab to show syntax for the concept statement and its input
sources and output targets.</p>

<h2 id="concept-examples">Concept Examples</h2>

<p>We show Inkling for the concepts get_high_score, Digit, Curvature, and Segments. </p>

<p>Select the Inkling tab to display the Inkling source. </p>

<h3 id="get_high_score">get_high_score</h3>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">concept</span> <span class="nx">get_high_score</span>
  <span class="k">is</span> <span class="nx">classifier</span>
  <span class="k">predicts</span> <span class="nx">PlayerMove</span>
  <span class="k">follows</span> <span class="kr">input</span><span class="p">(</span><span class="nx">GameState</span><span class="p">)</span>
  <span class="k">feeds</span> <span class="kr">output</span>
<span class="k">end</span>
</code></pre>
<p>In this example:</p>

<ul>
<li><code class="prettyprint">conceptName</code>: get_high_score</li>
<li><code class="prettyprint">kind</code>: classifier</li>
<li><code class="prettyprint">predicts</code>: PlayerMove</li>
<li><code class="prettyprint">input(schemaName)</code>: input(GameState)</li>
<li><code class="prettyprint">dependent</code>: output</li>
</ul>

<h3 id="digit">Digit</h3>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">concept</span> <span class="nx">Digit</span>
  <span class="k">is</span> <span class="nx">classifier</span>
  <span class="k">predicts</span> <span class="nx">MNIST_output</span>
  <span class="k">follows</span> <span class="nx">Curvature</span><span class="p">,</span> <span class="nx">Segments</span><span class="p">,</span> <span class="kr">input</span><span class="p">(</span><span class="nx">MNIST_input</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<p>In this example:</p>

<ul>
<li><code class="prettyprint">conceptName</code>: Digit</li>
<li><code class="prettyprint">kind</code>: classifier</li>
<li><code class="prettyprint">predicts</code>: MNIST_output</li>
<li><code class="prettyprint">Curvature</code>: a concept</li>
<li><code class="prettyprint">Segments</code>: another concept</li>
<li><code class="prettyprint">input(schemaName)</code>: <code class="prettyprint">input(MNIST_input)</code></li>
<li><code class="prettyprint">feeds:</code> output</li>
</ul>

<h3 id="curvature">Curvature</h3>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">concept</span> <span class="nx">Curvature</span>
  <span class="k">is</span> <span class="nx">classifier</span>
  <span class="k">predicts</span> <span class="p">(</span><span class="nx">curve_output</span><span class="p">)</span>
  <span class="k">follows</span> <span class="kr">input</span><span class="p">(</span><span class="nx">MNIST_input</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<p>In this example:</p>

<ul>
<li><code class="prettyprint">conceptName</code>: Curvature</li>
<li><code class="prettyprint">kind</code>: classifier</li>
<li><code class="prettyprint">predicts</code>: curve_output</li>
<li><code class="prettyprint">input(schemaName)</code>: <code class="prettyprint">input(MNIST_input)</code></li>
</ul>

<h3 id="segments">Segments</h3>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">concept</span> <span class="nx">Segments</span>
  <span class="k">is</span> <span class="nx">classifier</span>
  <span class="k">predicts</span> <span class="p">(</span><span class="nx">segments_output</span><span class="p">)</span>
  <span class="k">follows</span> <span class="kr">input</span><span class="p">(</span><span class="nx">MNIST_input</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<ul>
<li><code class="prettyprint">conceptName</code>: Segments</li>
<li><code class="prettyprint">kind</code>: classifier</li>
<li><code class="prettyprint">predicts</code>: segments_output</li>
<li><code class="prettyprint">input(schemaName)</code>: <code class="prettyprint">input(MNIST_input)</code></li>
</ul>

          <h1 id="schema">Schema</h1>

<p>This is the reference for the keyword <strong>schema</strong>. Also covered are the
definitions and uses of Inkling types, including type constraints.  These are used in schema declarations.</p>

<h3 id="what-is-it">What is it?</h3>

<p>In Inkling a <strong>schema</strong> describes a named record and its contained fields. Each field in a schema has a name and a type. A field may also have a type constraint that constrains the values that the datum described by this field will take.</p>

<h3 id="why-do-i-use-it">Why do I use it?</h3>

<p>Schemas describe the structure of data in Inkling  streams, such as the
predefined <code class="prettyprint">input</code> and <code class="prettyprint">output</code> streams. In addition, many Inkling statements (for
example <code class="prettyprint">concept</code> and <code class="prettyprint">curriculum</code>) use schema references to describe the data that flows in and out of the construct.</p>

<h3 id="how-do-i-use-it">How do I use it?</h3>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">schema</span> <span class="nx">MySchema</span>                   <span class="c1"># declare</span>
   <span class="kr">UInt8</span>  <span class="nx">field1</span><span class="p">,</span>
   <span class="kr">UInt32</span> <span class="nx">field2</span>
<span class="k">end</span>

<span class="k">concept</span> <span class="nx">MyConcept</span>
  <span class="k">is</span> <span class="nx">classifier</span>
    <span class="k">predicts</span> <span class="p">(</span><span class="nx">MySchema</span><span class="p">)</span>           <span class="c1"># use</span>
    <span class="k">follows</span> <span class="kr">input</span><span class="p">(</span><span class="kr">UInt64</span> <span class="nx">i</span><span class="p">)</span>       <span class="c1"># anonymous</span>
    <span class="k">feeds</span> <span class="kr">output</span>
<span class="k">end</span>
</code></pre>
<p>Select the Inkling tab to show a sample schema declaration and an example of its use.
Note that a schema reference can be anonymous. That means a list of name, type
pairs can appear where a schema name could appear.
‍</p>

<h2 id="schema-rules">Schema Rules</h2>

<ul>
<li>Inkling statements can reference schemas by name. Above, <code class="prettyprint">MyConcept</code> uses <code class="prettyprint">MySchema</code> as its <code class="prettyprint">predicts</code> schema.</li>
<li>Statements can use anonymous schemas. That means that a list of fields appears where a schema name could appear. Above, after <code class="prettyprint">follows</code>, the predefined stream <code class="prettyprint">input</code> has an anonymous schema with one field. This is useful in cases where you will only need that information once. In general, anywhere a schema name can appear, an anonymous schema can appear.</li>
<li>The set of types supported with schema fields consists of the set of Inkling primitive types and the set of Inkling structured types. These sets are specified in the <a href="#inkling-types">Inkling Types</a> section.</li>
<li>A schema field that has a primitive type can also have a type constraint that constrains the set of potential values for that field. Examples and syntax of type constraints are included in this chapter.</li>
</ul>

<h2 id="schema-declaration-syntax">Schema Declaration Syntax</h2>
<pre class="highlight inkling tab-inkling--syntax"><code><span class="nx">schemaStatement</span> <span class="p">::</span><span class="o">=</span>
  <span class="k">schema</span> <span class="o">&lt;</span><span class="nx">schemaName</span><span class="o">&gt;</span>
    <span class="nx">fieldDeclarationList</span>
  <span class="k">end</span>

<span class="nx">fieldDeclarationList</span> <span class="p">::</span><span class="o">=</span>
   <span class="nx">fieldDeclaration</span> 
   <span class="p">[','</span> <span class="nx">fieldDeclaration</span>  <span class="p">]</span><span class="o">*</span>

<span class="nx">fieldDeclaration</span>  <span class="p">::</span><span class="o">=</span>  
  <span class="nx">scalarDeclaration</span>   
  <span class="o">|</span> 
  <span class="nx">structureDeclaration</span> 

<span class="nx">scalarDeclaration</span>  <span class="p">::</span><span class="o">=</span>   
  <span class="nx">concreteType</span> <span class="nx">rangeExpression</span><span class="p">?</span>  
    <span class="o">&lt;</span><span class="nx">name</span><span class="o">&gt;</span> <span class="p">[</span> <span class="p">'['</span> <span class="nx">arraySizeLiteral</span> <span class="p">']'</span> <span class="p">]</span><span class="o">*</span> 

<span class="nx">structureDeclaration</span> <span class="p">::</span><span class="o">=</span> 
  <span class="nx">structure_type</span> <span class="nx">structure_init</span> 
    <span class="o">&lt;</span><span class="nx">name</span><span class="o">&gt;</span> <span class="p">[</span> <span class="p">'['</span> <span class="nx">arraySizeLiteral</span> <span class="p">']'</span> <span class="p">]</span><span class="o">*</span>

<span class="nx">structure_type</span> <span class="p">::</span><span class="o">=</span> 
  <span class="kr">Luminance</span> <span class="o">|</span> <span class="kr">Matrix</span>

<span class="nx">structure_init</span><span class="p">:</span><span class="o">=</span> 
  <span class="p">'('</span> 
      <span class="nx">luminance_init</span> 
   <span class="o">|</span> 
      <span class="nx">matrix_init</span> 
  <span class="p">')'</span>

<span class="nx">luminance_init</span> <span class="p">::</span><span class="o">=</span>  
  <span class="nx">integerLiteral</span> <span class="p">','</span> <span class="nx">integerLiteral</span> 

<span class="nx">matrix_init</span> <span class="p">::</span><span class="o">=</span> 
  <span class="p">'('</span> <span class="nx">concreteType</span> 
      <span class="p">[</span> <span class="p">','</span> <span class="nx">concretetype</span> <span class="p">]</span><span class="o">*</span> 
   <span class="p">')'</span> 

<span class="nx">scalarDeclaration</span> <span class="p">::</span><span class="o">=</span>
  <span class="nx">primitiveType</span> <span class="nx">typeConstraint</span><span class="p">?</span>
    <span class="o">&lt;</span><span class="nx">name</span><span class="o">&gt;</span> <span class="p">[</span> <span class="p">'['</span> <span class="nx">arraySizeLiteral</span> <span class="p">']'</span> <span class="p">]</span><span class="o">*</span>
</code></pre>
<p>Select the Syntax tab to view the schema declaration syntax.</p>

<p>In the syntax you will see references to Inkling primitive types and structure types
(Luminance, Matrix). These are discussed in in the Inkling Types section. </p>

<p>‍</p>

<h2 id="schema-reference-syntax">Schema Reference Syntax</h2>
<pre class="highlight inkling tab-inkling--syntax"><code><span class="nx">schemaReference</span> <span class="p">::</span><span class="o">=</span>
  <span class="p">'('</span> <span class="o">&lt;</span><span class="nx">name</span><span class="o">&gt;</span> <span class="p">')'</span>                  <span class="c1"># named reference</span>
  <span class="o">|</span> 
  <span class="p">'('</span> <span class="o">&lt;</span><span class="nx">fieldDeclarationList</span><span class="o">&gt;</span> <span class="p">')'</span>  <span class="c1"># anonymous reference</span>
</code></pre>
<p>Select the Syntax tab to view the schema reference syntax.</p>

<p>A named schema is referenced by its name. An anonymous schema is referenced by its list of fields.</p>

<h2 id="schema-example">Schema Example</h2>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">schema</span> <span class="nx">MNIST_training_data_schema</span>
  <span class="kr">UInt8</span> <span class="nx">label</span><span class="p">,</span>
  <span class="kr">Luminance</span><span class="p">(</span><span class="mi">28</span><span class="p">,</span> <span class="mi">28</span><span class="p">)</span> <span class="nx">image</span>
<span class="k">end</span>
</code></pre>
<p>Select the Inkling tab to show a schema that has a field with a primitive type and a field with a structured type.</p>

<h2 id="inkling-types">Inkling Types</h2>

<h6 id="primitive-types">Primitive Types</h6>
<pre class="highlight inkling tab-inkling--syntax"><code><span class="nx">primitiveType</span> <span class="p">::</span><span class="o">=</span>
  <span class="kr">Double</span> <span class="o">|</span> <span class="kr">Float64</span> <span class="o">|</span> <span class="kr">Float32</span> <span class="o">|</span> <span class="kr">Int8</span> <span class="o">|</span> <span class="kr">Int16</span> <span class="o">|</span> <span class="kr">Int32</span> <span class="o">|</span>
  <span class="kr">Int64</span> <span class="o">|</span> <span class="kr">UInt8</span> <span class="o">|</span> <span class="kr">UInt16</span> <span class="o">|</span> <span class="kr">UInt32</span>  <span class="o">|</span> <span class="kr">UInt64</span> <span class="o">|</span> <span class="kr">Bool</span> <span class="o">|</span> <span class="kr">String</span>
</code></pre>
<p>Select the Syntax tab to show the Inkling set of primitive types which are used in schema declarations. The
integer suffix indicates the size in bits of the type. Integer types beginning
with &lsquo;U&rsquo; are unsigned. </p>

<h6 id="structured-types">Structured Types</h6>
<pre class="highlight inkling tab-inkling--syntax"><code><span class="nx">structure_type</span> <span class="p">::</span><span class="o">=</span> 
  <span class="kr">Luminance</span> <span class="o">|</span> <span class="kr">Matrix</span>
</code></pre>
<p>Inkling currently supports the types Matrix and Luminance. (This list will be
expanded.)</p>

<p>See the schema declaration syntax for the complete syntax of structure declaration.</p>

<p>‍</p>

<h6 id="constrained-types">Constrained Types</h6>
<pre class="highlight inkling tab-inkling--code"><code>  <span class="c1"># Example: Range expression</span>

  <span class="k">schema</span> <span class="nx">Schema1</span>
    <span class="kr">Int8</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="mi">10</span><span class="p">}</span> <span class="nx">field</span>   <span class="c1"># start:step:stop (all are numeric literals)</span>
  <span class="k">end</span>

 <span class="c1"># Curly braces delineate the range expression.</span>
 <span class="c1"># The values in this range are: (0, 3, 6, 9).</span>
 <span class="c1"># Note that the specification of 10 as the stop does not mean</span>
 <span class="c1"># 10 must be in the range (because it is a limit, not </span>
 <span class="c1"># necessarily an endpoint).</span>
</code></pre>
<p>Constrained types are supported in schemas and also in <a href="#lesson">lessons</a>. They are constrained by means of a special type of expression called a range expression.</p>

<p>A range expression has the effect of constraining the values of the type to values defined by the range expression. In a schema this constrains the values in the field. In lessons this constrains the values of the placeholder being configured. In both cases the syntax is the same.</p>

<p>Select the Inkling tab to see an example of a constrained type in a schema definition. </p>

<h3 id="constrained-type-syntax">Constrained Type Syntax</h3>
<pre class="highlight inkling tab-inkling--syntax"><code><span class="nx">constrainedType</span> <span class="p">::</span><span class="o">=</span>
<span class="nx">primitiveType</span>
<span class="p">'{'</span>
  <span class="nx">start</span> <span class="p">':'</span> <span class="p">[</span> <span class="nx">step</span><span class="p">':']?</span> <span class="nx">stop</span>      <span class="c1"># A 'colon range'. Specifies 'step' </span>
  <span class="o">|</span>
  <span class="nx">start</span> <span class="p">'.'</span> <span class="p">'.'</span> <span class="nx">stop</span> <span class="p">':'</span> <span class="nx">numSteps</span> <span class="c1"># A 'dot range'. Specifies 'numsteps'.</span>
<span class="p">'}'</span>
</code></pre>
<p>Select the Syntax tab to view the constrained type syntax.</p>

<p>Note that start, stop, step, numSteps are all numeric literals.</p>

<p>‍</p>

<h6 id="range-expression-rules">Range Expression Rules</h6>

<p>There are three forms of range expressions which Inkling supports. 
Select the Inkling tab to see an example of each type.</p>
<pre class="highlight inkling tab-inkling--code"><code><span class="c1"># Example: Value list range expression</span>
<span class="k">schema</span> <span class="nx">Schema2</span>
  <span class="kr">UInt8</span>  <span class="p">{</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">}</span>   <span class="nx">num</span><span class="p">,</span> <span class="c1"># a set of UInt8 values</span>
  <span class="kr">String</span> <span class="p">{</span><span class="s2">"a"</span><span class="p">,</span> <span class="s2">"bc"</span><span class="p">}</span>   <span class="nx">cat</span>  <span class="c1"># a set of Strings</span>
<span class="k">end</span>
</code></pre>
<ul>
<li><strong>Value list range expression</strong></li>
</ul>

<p>A value list range expression is simply a list of values.
These range expressions specify sets of values in 
which each value is explicitly listed.</p>
<pre class="highlight inkling tab-inkling--code"><code><span class="c1"># Example: Range expression, colon range type</span>
<span class="k">schema</span> <span class="nx">Schema3</span>
  <span class="kr">Int64</span>  <span class="p">{</span> <span class="mi">0</span><span class="p">:</span><span class="mi">5</span><span class="p">:</span><span class="mi">100</span> <span class="p">}</span>   <span class="nx">x</span><span class="p">,</span>   <span class="c1"># start:step:stop, step= 5,0..100</span>
  <span class="kr">Int64</span>  <span class="p">{</span> <span class="mi">0</span><span class="p">:</span><span class="mi">100</span> <span class="p">}</span>     <span class="nx">y</span>    <span class="c1"># start:stop, step= 1, 0..100</span>
<span class="k">end</span>
</code></pre>
<ul>
<li><strong>Colon range expression</strong></li>
</ul>

<p>Colon range expressions specify values for the start, 
the step, and the stop. </p>

<ul>
<li>If the step value is missing, 1 is the default. </li>
<li>Step can be  a floating point number.</li>
<li>The step size can be negative only if stop &lt; start.</li>
</ul>
<pre class="highlight inkling tab-inkling--code"><code><span class="c1"># Example: Range expression, dot range type</span>
<span class="k">schema</span> <span class="nx">Schema4</span>
  <span class="kr">Int64</span>  <span class="p">{</span> <span class="mi">0</span><span class="p">..</span><span class="mi">100</span><span class="p">:</span><span class="mi">25</span> <span class="p">}</span> <span class="nx">z</span><span class="p">,</span>   <span class="c1"># start:stop, numsteps=25</span>
  <span class="kr">Float32</span> <span class="p">{</span> <span class="mi">0</span><span class="p">..</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">}</span>    <span class="nx">a</span>    <span class="c1"># yields (0, 0.5, 1.0, 1.5, 2.0)</span>
<span class="k">end</span>
</code></pre>
<ul>
<li><strong>Dot range expression</strong></li>
</ul>

<p>Dot range expressions specify values for start, stop, and number of steps. </p>

<ul>
<li><p>The number of steps (numSteps) must be a positive integer.</p></li>
<li><p><strong>Numeric Range Expression Start Point</strong></p></li>
</ul>

<p>The start point of a numeric range is inclusive (it is included in the values of the range) and fixed. 
The range start point is exact (to the maximum extent possible if the range expression type is floating point). </p>

<ul>
<li><strong>Numeric Range Expression End Point</strong></li>
</ul>
<pre class="highlight inkling tab-inkling--code"><code> <span class="c1"># Valid and Invalid Range Expressions.</span>

 <span class="kr">Int64</span>  <span class="p">{</span> <span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">1</span> <span class="p">}</span>  <span class="nx">field1</span><span class="p">,</span>  <span class="c1"># INVALID. step size &gt; range.</span>
 <span class="kr">Int64</span>  <span class="p">{</span> <span class="mi">0</span><span class="p">..</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span> <span class="p">}</span> <span class="nx">field2</span><span class="p">,</span>  <span class="c1"># INVALID. Values are floating point not integer.</span>
 <span class="kr">Float32</span><span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">..</span><span class="mi">1</span><span class="p">:</span><span class="mi">10</span> <span class="p">}</span> <span class="nx">field3</span><span class="p">,</span> <span class="c1"># VALID.   Negative bounds allowed.</span>
 <span class="kr">Int8</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">4</span><span class="p">:</span><span class="o">-</span><span class="mi">100</span><span class="p">}</span> <span class="nx">field4</span><span class="p">,</span>   <span class="c1"># VALID.   stop  &lt; start is valid if step is negative.</span>
 <span class="kr">UInt32</span> <span class="p">{</span><span class="o">-</span><span class="mi">10</span><span class="p">:</span><span class="mi">10</span><span class="p">}</span>  <span class="nx">field4</span>    <span class="c1"># INVALID. Unsigned integer range contains signed values.</span>
</code></pre>
<p>The end point specified in the range expression may or may not be included in the values of the range. 
The range end is a limit. That means that if applying the step results in landing exactly on the end point, then the end point is part of the range. Otherwise the highest value landed on that is less than the end point is the final value in the range.</p>

<p>Select the Inkling tab to view some examples of valid and invalid ranges.</p>

<p>‍</p>

          <h1 id="training-source">Training Source</h1>

<p>The Bonsai Platform supports training with both real and synthetic data. The <code class="prettyprint">data</code>, <code class="prettyprint">simulator</code> and <code class="prettyprint">generator</code> keywords are used to describe what kind of training source you would like to use for training.</p>

<aside class="notice">
Currently, during the Bonsai Platform preview, you can <b>only</b> train with simulators as your training source. That is, only the <i>simulator</i> training specifier is supported.
</aside>

<h3 id="simulators">Simulators</h3>

<p>Simulators are interactive virtual environments. Every simulator has state, a representation of the world inside the virtual environment. This state almost always changes over time and in response to actions taken by an AI or other agent. The AI and the simulator are in a loop where a BRAIN is receiving a frame of state from the simulator, then, the BRAIN is selecting a next action. Next, the simulator changes state in response to that action. The BRAIN then receives this new updated frame of state from the simulator and selects a new next action, so on and so on until the BRAIN learns how to best operate the simulation.</p>

<p>Our <a href="library-reference.html">Library Reference</a> describes the classes and methods used to connect an existing simulator or create a new simulator in Python. <a href="../examples.html#find-the-center-example">Find the Center</a> is an example of a basic simulator implementation.</p>

<h3 id="generators">Generators</h3>

<p>Generators produce labeled data programmatically. This data is effectively infinite. A generator could, for example, produce a random (but known) integer, set of line segments, etc.</p>

<aside class="notice">
Currently, during the Bonsai Platform preview, you can <b>only</b> train with simulators as your training source. That is <i>generators</i> are not supported.
</aside>

<h3 id="data">Data</h3>

<p>Data is information related to the scenario being trained comprising of columns of information with input values and expected labels or desired predicted values. Data is used both for training and evaluating the quality of training. Examples of training data include a collection of images and labels or the rows and columns of a spreadsheet.</p>

<aside class="notice">
Currently, during the Bonsai Platform preview, you can <b>only</b> train with simulators as your training source. That is <i>data</i> is not supported.
</aside>

<h2 id="simulator-clause-syntax">Simulator Clause Syntax</h2>
<pre class="highlight inkling tab-inkling--syntax"><code><span class="k">simulator</span> <span class="o">&lt;</span><span class="nx">simulatorName</span><span class="o">&gt;</span><span class="p">'('</span><span class="o">&lt;</span><span class="nx">configurationSchema</span><span class="o">&gt;</span><span class="p">')'</span> 
  <span class="k">state</span> <span class="p">'('</span><span class="o">&lt;</span><span class="nx">stateSchema</span><span class="o">&gt;</span><span class="p">')'</span>     <span class="c1"># simulator state</span>
  <span class="nx">control</span> <span class="p">'('</span><span class="o">&lt;</span><span class="nx">controlSchema</span><span class="o">&gt;</span><span class="p">')'</span> <span class="c1"># training concept predicts schema</span>
<span class="k">end</span>
</code></pre>
<p>Select the Syntax tab to see the Simulator clause syntax.</p>

<p>When a simulator is used for training, use the simulator clause. It is <strong>required</strong> to pass a <configurationSchema> into the simulator, even if the configuration is empty.</p>

<p>The <a href="#curriculum">Mountain Car example</a> of a simulator shows the implementation of this clause in a curriculum.</p>

          <h1 id="curriculum">Curriculum</h1>

<p>Reference for the keyword <strong>curriculum</strong>. Also, describes the keywords: <strong>train</strong>, <strong>with</strong></p>

<h3 id="what-is-it">What is it?</h3>

<p>The <strong>curriculum</strong> (keyword) declares a set of lessons that are used to teach concepts. Each curriculum contains a lesson or set of lessons and trains a single concept.</p>

<h3 id="why-do-i-use-it">Why do I use it?</h3>

<p>A curriculum is used to teach a concept. The curriculum defines what concept is being taught. Every concept needs a corresponding curriculum to teach it. A curriculum defines a set of lessons used to train the concept.</p>

<h3 id="how-do-i-use-it">How do I use it?</h3>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">curriculum</span> <span class="nx">curriculumName</span>
  <span class="k">train</span> <span class="nx">conceptName</span>
  <span class="k">with</span> <span class="nx">trainingSpecifier</span>  <span class="c1"># one of data, simulator, or generator</span>
  <span class="k">objective</span> <span class="nx">objectiveName</span>
    <span class="c1"># lessons are specified here.</span>
<span class="k">end</span>
</code></pre>
<p>Select the Inkling tab to see a simple form of a curriculum statement.</p>

<p>The <em>trainingSpecifier</em> specifies either <code class="prettyprint">data</code>, <code class="prettyprint">simulator</code>, or <code class="prettyprint">generator</code> as the training source. Refer back to <a href="#training-source">Training Source</a> for more information on what the differences are.</p>

<aside class="notice">
Currently, only simulator training sources are supported. When the <i>trainingspecifier</i> is <b>simulator</b>, the objective names a function which is specified in the associated simulator. The use of simulators requires an auxiliary <i>simulator</i> clause. 
</aside>

<p>The <code class="prettyprint">objective</code> specifies the termination condition for training.</p>

<h3 id="mountain-car-example">Mountain Car Example</h3>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">simulator</span> <span class="nx">mountaincar_simulator</span><span class="p">(</span><span class="nx">MountainCarConfig</span><span class="p">)</span> 
  <span class="k">state</span> <span class="p">(</span><span class="nx">GameState</span><span class="p">)</span>
  <span class="nx">control</span> <span class="p">(</span><span class="nx">Action</span><span class="p">)</span>
<span class="k">end</span>
</code></pre><pre class="highlight inkling tab-inkling--code"><code><span class="k">curriculum</span> <span class="nx">high_score_curriculum</span>
<span class="k">train</span> <span class="nx">high_score</span>
<span class="k">with</span> <span class="k">simulator</span> <span class="nx">mountaincar_simulator</span> 
<span class="k">objective</span> <span class="nx">open_ai_gym_default_objective</span>
  <span class="k">lesson</span> <span class="nx">get_high_score</span>
    <span class="k">configure</span>
      <span class="k">constrain</span> <span class="nx">episode_length</span> <span class="k">with</span> <span class="kr">Int8</span><span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">},</span>
      <span class="k">constrain</span> <span class="nx">deque_size</span> <span class="k">with</span> <span class="kr">UInt8</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span>
    <span class="k">until</span>
      <span class="k">maximize</span> <span class="nx">open_ai_gym_default_objective</span>
<span class="k">end</span>
</code></pre>
<p>Select the Inkling tab to view an excerpt of the code in the game Mountain Car from
OpenAI Gym as written in Inkling. This illustrates the <a href="#simulator-clause-syntax">simulator clause</a>.  (To explore this example more fully,
refer to it in our <a href="../examples.html#mountain-car-example">Examples chapter</a>.)</p>

<p>The simulator clause declares the simulator name and two schemas. The first specifies the schema for configuration of the simulator and it appears in parentheses immediately after the simulator name. In this instance, the configuration schema is named <code class="prettyprint">MountainCarConfig</code>. In the example, the configure clause of lesson <code class="prettyprint">get_high_score</code> initializes this configuration.</p>
<pre class="highlight inkling tab-inkling--code"><code><span class="c1"># Configuration schema declaration</span>
<span class="k">schema</span> <span class="nx">MountainCarConfig</span>
  <span class="kr">Int8</span> <span class="nx">episode_length</span><span class="p">,</span>
  <span class="kr">UInt8</span> <span class="nx">deque_size</span>
<span class="k">end</span>
</code></pre>
<p>The names in the configuration schema are the names referenced in the configure
clause of <code class="prettyprint">lesson get_high_score</code>. When the lesson is
initiated, the configuration data as described in the configuration schema is sent
to the simulator. The configuration data will be generated according to the
range expression in the lesson configure clause for a field. </p>

<p>The second schema specified in the simulator clause is the state schema. It is
specified after the <strong>state</strong> keyword in the simulator clause. This is the schema that defines what is sent to the lesson. Recall that a simulator has state. That means that input to the lesson will consist of the state of the game as a result of the previous lesson execution. For mountaincar this schema is called <code class="prettyprint">GameState</code> and prior state consists of prior position.</p>
<pre class="highlight inkling tab-inkling--code"><code><span class="c1"># State schema definition</span>
<span class="k">schema</span> <span class="nx">GameState</span>
  <span class="kr">Float32</span> <span class="nx">x_position</span><span class="p">,</span>
  <span class="kr">Float32</span> <span class="nx">x_velocity</span>
<span class="k">end</span>
</code></pre>
<p>In order to determine what our next move will be, the training will use the previous position as input.</p>

<p>Finally, note that <code class="prettyprint">high_score_curriculum</code> trains a concept called <code class="prettyprint">high_score</code>.  (It&rsquo;s quite clear what we are aiming for with this curriculum!)</p>
<pre class="highlight inkling tab-inkling--code"><code><span class="c1"># Predict schema Action (see concept high_score)</span>
<span class="k">schema</span> <span class="nx">Action</span>
  <span class="kr">Int8</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span> <span class="k">action</span> <span class="c1"># these values describe game moves</span>
<span class="k">end</span>

<span class="k">concept</span> <span class="nx">high_score</span>
  <span class="k">is</span> <span class="nx">classifier</span>
  <span class="k">predicts</span> <span class="p">(</span><span class="nx">Action</span><span class="p">)</span>
  <span class="k">follows</span> <span class="kr">input</span><span class="p">(</span><span class="nx">GameState</span><span class="p">)</span>    
  <span class="k">feeds</span> <span class="kr">output</span>
<span class="k">end</span>
</code></pre>
<p>The concept <code class="prettyprint">high_score</code> trains the Brain to select the next move, which will have
one of the values specified in the <code class="prettyprint">Action</code> schema range expression. </p>

<p>Note that the predefined stream <strong>input</strong> has the schema <code class="prettyprint">GameState</code>. This reflects that fact that the simulator has state. The previous move is the state which is input into the selection of the next move.</p>

<p>The <strong>predicts</strong> schema <code class="prettyprint">Action</code> also appears in the simulator clause discussed above. It is after the keyword <strong>control</strong>. In general the <strong>control</strong> schema is the <strong>predicts</strong> schema of the concept being trained.</p>

<p>So far we have presented a simple version of the curriculum. Inkling supports
multiple simulators and generators within a single curriculum. Here is the full
syntax for the curriculum statement, which introduces a <strong>using</strong> clause and a
<strong>with</strong> clause (where <strong>using</strong> and <strong>with</strong> will specify simulators). These were not needed in our example above because we were using a single simulator.</p>

<h2 id="curriculum-rules">Curriculum Rules</h2>

<ul>
<li>One curriculum per concept. </li>
<li>Every concept must have a curriculum.</li>
<li>Every simulator must be declared with a <a href="#simulator-clause-syntax">simulator clause</a>.</li>
<li>Lessons and tests can occur in any order.</li>
<li>If the <strong>using</strong> clause is present (that is, if the simplified curriculum syntax is not being used), there must be one <strong>using</strong> clause for every <strong>with</strong> clause.</li>
<li>The objective is always required.</li>
</ul>

<h2 id="curriculum-statement-syntax">Curriculum Statement Syntax</h2>
<pre class="highlight inkling tab-inkling--syntax"><code><span class="nx">curriculumStatement</span> <span class="p">::</span><span class="o">=</span>
<span class="k">curriculum</span> <span class="o">&lt;</span><span class="nx">name</span><span class="o">&gt;</span>
    <span class="k">train</span> <span class="o">&lt;</span><span class="nx">conceptName</span><span class="o">&gt;</span>
<span class="p">[</span>
  <span class="nx">withClause</span>                        <span class="c1"># with clause</span>

<span class="p">]</span><span class="o">+</span>
<span class="p">[</span>
  <span class="k">using</span> <span class="o">&lt;</span><span class="nx">simulatorName</span><span class="o">&gt;</span>             <span class="c1"># using clause</span>
  <span class="p">[</span>
    <span class="nx">lessonClause</span> <span class="c1"># lesson set for this simulator</span>
  <span class="p">]</span><span class="o">+</span>

  <span class="k">end</span> <span class="c1"># using</span>
<span class="p">]</span><span class="o">+</span>
<span class="k">end</span> <span class="c1"># curriculum</span>
</code></pre><pre class="highlight inkling tab-inkling--syntax"><code><span class="nx">withClause</span> <span class="p">::</span><span class="o">=</span>
<span class="k">with</span> <span class="k">simulator</span>
  <span class="k">objective</span> <span class="o">&lt;</span><span class="nx">objectiveFunctionName</span><span class="o">&gt;</span>
</code></pre>
<p>Select the Syntax tab to see the Curriculum syntax.</p>

<p>Any simulator referenced in a curriculum must have an associated simulator clause, outlined in <a href="#training-source">Training Source</a>.</p>

          <h1 id="lesson">Lesson</h1>

<p>Reference for the keyword <strong>lesson</strong>. Also, describes the keywords: <strong>follows</strong>, <strong>configure</strong>, <strong>constrain</strong>, <strong>until</strong>, <strong>minimize</strong>, <strong>maximize</strong>, <strong>configure</strong>, <strong>with</strong>, and <strong>end.</strong></p>

<h3 id="what-is-it">What is it?</h3>

<p>The <strong>lesson</strong> (keyword) declares an individual lesson for the concept being trained by the curriculum.  Lessons are contained within curriculum statements. A curriculum can contain multiple lessons.</p>

<h3 id="why-do-i-use-it">Why do I use it?</h3>

<p>Lessons give you control over the training of the mental model. They allow you to break down the training of the concept into phases where each phase is implemented by a lesson.</p>

<h3 id="how-do-i-use-it">How do I use it?</h3>
<pre class="highlight inkling tab-inkling--syntax"><code><span class="k">lesson</span> <span class="nx">lessonName</span>
    <span class="k">follows</span> <span class="nx">prevLessonName</span>
  <span class="nx">configureClause</span>
  <span class="nx">trainClause</span>
  <span class="nx">testClause</span>
  <span class="nx">untilClause</span>
</code></pre>
<p>Select the Syntax tab to show the clauses a lesson can contain.</p>

<p>Lessons allow the machine to learn the concept in stages rather than all at
once. </p>

<p>Here are the overall lesson rules:</p>

<ul>
<li>Lesson statements appear within curriculum statements.</li>
<li>Lesson statements may contain the following keywords: <strong>configure</strong>, <strong>train</strong>, <strong>test</strong>, and <strong>until</strong>.</li>
<li>Lessons appear after the objective clause in curriculums.</li>
<li>Lessons can be ordered, using the <strong>follows</strong> clause. Note that this ordering is a suggestion to the instructor, not a hard and fast rule.</li>
</ul>

<p>Lessons have <strong>configure</strong>, <strong>test</strong>, <strong>train</strong>, and <strong>until</strong> clauses. 
Some lesson clauses have defaults so if a clause is not specified the default
will be in effect. Also in certain circumstances not all clauses are available.
See the lesson clauses table in this chapter for the rules which apply to a specific
clause.</p>

<h3 id="breakout-example">Breakout Example</h3>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">schema</span> <span class="nx">BreakoutConfig</span>   <span class="c1"># configured in lesson configureClause</span>
  <span class="kr">UInt32</span> <span class="nx">level</span><span class="p">,</span>
  <span class="kr">UInt8</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">}</span> <span class="nx">paddle_width</span><span class="p">,</span>
  <span class="kr">Float32</span> <span class="nx">bricks_percent</span>
<span class="k">end</span>

<span class="k">curriculum</span> <span class="nx">ball_location_curriculum</span>
  <span class="k">train</span> <span class="nx">ball_location</span>
  <span class="k">with</span> <span class="k">simulator</span> <span class="nx">breakout_simulator</span>
  <span class="k">objective</span> <span class="nx">ball_location_distance</span>

    <span class="k">lesson</span> <span class="nx">constant_breakout</span>
      <span class="k">configure</span>           <span class="c1"># configure to constant values</span>
        <span class="k">constrain</span> <span class="nx">bricks_percent</span> <span class="k">with</span> <span class="kr">Float32</span><span class="p">{</span><span class="mf">0.5</span><span class="p">},</span>
        <span class="k">constrain</span> <span class="nx">level</span> <span class="k">with</span> <span class="kr">UInt32</span><span class="p">{</span><span class="mi">1</span><span class="p">},</span>    <span class="c1"># e.g. level = 1</span>
        <span class="k">constrain</span> <span class="nx">paddle_width</span> <span class="k">with</span> <span class="kr">UInt8</span><span class="p">{</span><span class="mi">4</span><span class="p">}</span>
      <span class="k">train</span>
        <span class="k">from</span> <span class="nx">frame</span> <span class="k">in</span> <span class="nx">breakout_simulator</span>
        <span class="k">select</span> <span class="nx">frame</span>
        <span class="k">send</span> <span class="nx">frame</span>
      <span class="k">test</span>
        <span class="k">from</span> <span class="nx">frame</span> <span class="k">in</span> <span class="nx">breakout_simulator</span>
        <span class="k">select</span> <span class="nx">frame</span>
        <span class="k">send</span> <span class="nx">frame</span>
      <span class="k">until</span>
        <span class="k">minimize</span> <span class="nx">ball_location_distance</span>

    <span class="k">lesson</span> <span class="nx">vary_breakout</span> <span class="k">follows</span> <span class="nx">constant_breakout</span>
      <span class="k">configure</span>          <span class="c1"># configure to type constraints</span>
      <span class="k">constrain</span> <span class="nx">bricks_percent</span> <span class="k">with</span> <span class="kr">Float32</span><span class="p">{</span><span class="mf">0.1</span><span class="p">:</span><span class="mf">0.01</span><span class="p">:</span><span class="mf">1.0</span><span class="p">},</span>
      <span class="k">constrain</span> <span class="nx">level</span> <span class="k">with</span> <span class="kr">UInt32</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">100</span><span class="p">},</span> <span class="c1"># e.g. level varies from 1..100</span>
      <span class="k">constrain</span> <span class="nx">paddle_width</span> <span class="k">with</span> <span class="kr">UInt8</span><span class="p">{</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">}</span>
    <span class="k">train</span>
      <span class="k">from</span> <span class="nx">frame</span> <span class="k">in</span> <span class="nx">breakout_simulator</span>
      <span class="k">select</span> <span class="nx">frame</span>
      <span class="k">send</span> <span class="nx">frame</span>
    <span class="k">test</span>
      <span class="k">from</span> <span class="nx">frame</span> <span class="k">in</span> <span class="nx">breakout_simulator</span>
      <span class="k">select</span> <span class="nx">frame</span>
      <span class="k">send</span> <span class="nx">frame</span>
    <span class="k">until</span>
      <span class="k">minimize</span> <span class="nx">ball_location_distance</span>
<span class="k">end</span>
</code></pre>
<p>In this example we show lessons that break into stages the task of  playing
the game breakout. The first lesson, <code class="prettyprint">constant_breakout</code>, trains the machine
with a set of fixed values as configuration parameters. The second lesson,
<code class="prettyprint">vary_breakout</code>, which <strong>follows</strong> <code class="prettyprint">constant_breakout</code>, trains the machine with a set of configuration parameters that vary according to specified type constraints.</p>

<p>The two lessons in our example, <code class="prettyprint">constant_breakout</code> and <code class="prettyprint">vary_breakout</code>, are different in their configure clause. The first sets the fields in the configuration schema to constant values and the second lesson, <code class="prettyprint">vary_breakout</code>, generates sets of values constrained by the type constraint. </p>

<p>Note that the <strong>constrain</strong> name in our example specifies a field in the
configuration schema for the simulator. These fields are <code class="prettyprint">bricks_percent</code>,
<code class="prettyprint">level</code>, and <code class="prettyprint">paddle_width</code>. When such fields are initialized with values from a
type constraint they are often called <strong>placeholders</strong>.  This means that the name is is not the name of a specific value but rather it is the name of a range of values which will be input during training.</p>

<p>You can find more discussion of type constraint rules in the <a href="#schema">schema</a> section. (Schema declarations can also use type constraints.)</p>

<h2 id="lesson-clause-table">Lesson Clause Table</h2>

<p>Lesson clauses have defaults so if a clause is not specified the default will be assumed. Also in certain circumstances not all clauses are available. This table specifies the rules. Recall that the <em>trainingSpecifier</em> appears after the keyword <strong>with</strong> in the curriculum.</p>

<p><strong>Table for Lesson Clauses</strong></p>

<table><thead>
<tr>
<th>training specifier</th>
<th>configure clause</th>
<th>train clause</th>
<th>test clause</th>
<th>until clause</th>
</tr>
</thead><tbody>
<tr>
<td><strong>data</strong></td>
<td>Not allowed.</td>
<td>Must have train or test at a minimum. Defaults to none.</td>
<td>Must have train or test at a mininum. Defaults to none.</td>
<td>Not user specified. Will default to: <em>minimize objectiveName</em>.</td>
</tr>
<tr>
<td><strong>generator</strong></td>
<td>Required.</td>
<td>If neither train nor test is present, defaults to: <em>from item in generator select item send item.image expects item.label</em>.</td>
<td>If neither train nor test is present, defaults to: <em>from item in generator select item send item.image expect item.label</em>. If not present, generate default for every lesson.</td>
<td>Not user specified. Will default to: <em>minimize objectiveName</em>.</td>
</tr>
<tr>
<td><strong>simulator</strong></td>
<td>Required.</td>
<td>If neither train nor test is present, defaults to: <em>item in simulator select item send item</em>.</td>
<td>If neither train nor test is present, defaults to: <em>from item in simulator select item</em>. If not present, generate default for every lesson.</td>
<td>Required.</td>
</tr>
</tbody></table>

<aside class="notice">
Currently, during the Bonsai Platform preview, you can only use simulators as your training source.
</aside> 

<h6 id="lesson-clause-rules">Lesson Clause Rules</h6>

<ul>
<li>To summarize the table above, for a lesson associated with a <em>trainingSpecifier</em> of <strong>data</strong>: one or both of the lesson clauses <strong>train</strong> and <strong>test</strong> are required (and there are no default versions of these clauses).</li>
<li>Test clause is optional for any particular lesson. However if the last lesson has no test clause it is an error.</li>
<li>The <strong>follows</strong> clause on the lesson is optional. <strong>Note:</strong> If there is no <strong>follows</strong> clause and the lessons are executed in parallel, training will be slower.</li>
<li>To summarize the table above: for a lesson associated with a <em>trainingSpecifier</em> of <strong>generator</strong> or <strong>simulator</strong>:

<ul>
<li>if neither the <strong>test</strong> or <strong>train</strong> lesson clauses are present, defaults for both clauses are generated. (See the above table for default details.) Otherwise, no defaults are generated.</li>
</ul></li>
</ul>

<h2 id="lesson-syntax">Lesson Syntax</h2>
<pre class="highlight inkling tab-inkling--syntax"><code><span class="nx">lessonStatement</span> <span class="p">::</span><span class="o">=</span>
  <span class="k">lesson</span> <span class="o">&lt;</span><span class="nx">lessonName</span><span class="o">&gt;</span>
    <span class="p">[</span><span class="k">follows</span> <span class="o">&lt;</span><span class="nx">lessonName</span><span class="o">&gt;</span><span class="p">]?</span>
    <span class="nx">configureClause</span><span class="p">?</span>
    <span class="nx">trainClause</span><span class="p">?</span>
    <span class="nx">untilClause</span><span class="p">?</span>
    <span class="nx">testClause</span><span class="p">?</span>
</code></pre>
<p>Select the Syntax tab to see the lesson syntax. The syntax for lesson and its subordinate
clauses is displayed.</p>

<h6 id="lesson-configure-clause-syntax">Lesson Configure Clause Syntax</h6>
<pre class="highlight inkling tab-inkling--syntax"><code><span class="nx">configureClause</span> <span class="p">::</span><span class="o">=</span>
<span class="k">configure</span>
  <span class="p">[</span><span class="k">constrain</span> <span class="o">&lt;</span><span class="nx">configSchemaFieldName</span><span class="o">&gt;</span> <span class="k">with</span> <span class="nx">constrainedType</span><span class="p">]</span><span class="o">+</span>
</code></pre>
<p>Select the Syntax tab for the syntax for this clause.</p>

<h6 id="lesson-train-test-clause-syntax">Lesson Train/Test Clause Syntax</h6>
<pre class="highlight inkling tab-inkling--syntax"><code><span class="nx">trainClause</span> <span class="p">::</span><span class="o">=</span>
<span class="k">train</span>
  <span class="nx">fromClause</span>
  <span class="k">send</span> <span class="o">&lt;</span><span class="nx">name</span><span class="o">&gt;</span>
<span class="nx">trainingSpecifer</span>
</code></pre><pre class="highlight inkling tab-inkling--syntax"><code><span class="nx">testClause</span> <span class="p">::</span><span class="o">=</span>
<span class="k">test</span>
  <span class="nx">fromClause</span>
  <span class="k">send</span> <span class="o">&lt;</span><span class="nx">name</span><span class="o">&gt;</span>
<span class="nx">trainingSpecifer</span>
</code></pre>
<p>Select the Syntax tab for the syntax for these clauses.</p>

<p>The <strong>test</strong> clause and the <strong>train</strong> clause have identical syntax except for
their keyword (<strong>train</strong> or <strong>test</strong>).  However they both vary depending on the
<em>trainingSpecifier</em> in the curriculum. </p>

<p>The <strong>from</strong> clause in the test/train syntax is used to name and describe the
training data that is sent by the system (either from a labeled data set, in the
<strong>data</strong> case, or by the generator or simulator) to the lesson.</p>

<h6 id="lesson-until-clause-syntax">Lesson Until Clause Syntax</h6>
<pre class="highlight inkling tab-inkling--syntax"><code><span class="nx">untilClause</span> <span class="p">::</span><span class="o">=</span>
<span class="k">until</span>
      <span class="p">[</span> <span class="k">minimize</span> <span class="o">|</span> <span class="k">maximize</span> <span class="p">]</span> <span class="o">&lt;</span><span class="nx">objectiveFunctionName</span><span class="o">&gt;</span>
    <span class="o">|</span>
      <span class="o">&lt;</span><span class="nx">objectiveFunctionName</span><span class="o">&gt;</span> <span class="nx">relOp</span> <span class="nx">constantExpression</span>

<span class="nx">relOp</span> <span class="p">::</span><span class="o">=</span>
  <span class="p">'</span><span class="o">==</span><span class="p">'</span> <span class="o">|</span> <span class="p">'</span><span class="o">&lt;</span><span class="p">'</span> <span class="o">|</span> <span class="p">'</span><span class="o">&gt;</span><span class="p">'</span> <span class="o">|</span> <span class="p">'</span><span class="o">&lt;=</span><span class="p">'</span> <span class="o">|</span> <span class="p">'</span><span class="o">&gt;=</span><span class="p">'</span>
</code></pre>
<p>Select the Syntax tab for the <strong>until</strong> clause syntax.</p>

<p>The <strong>until</strong> clause is required if the curriculum <em>trainingSpecifier</em> is <strong>simulator</strong>. If it is not present, a default with value minimize will be created.</p>

<p>The <strong>until</strong> clause in the lesson specifies the termination condition for training. The <strong>until</strong> clause in our breakout example above was this:</p>

<p><em>until minimize ball_location_distance</em></p>

<p>‍
This means train until the curriculum objective (<code class="prettyprint">ball_location_distance</code>) is minimized. </p>

          <h1 id="import">Import</h1>

<p>Reference for the keyword <strong>import</strong>. Also, describes the keywords: <strong>from</strong></p>

<p>Note: Currently, the only function you can import is <strong>split</strong>.</p>

<h3 id="what-is-it">What is it?</h3>

<p><strong>import</strong> (the keyword) describes the usage and location of functions that are part of external libraries.</p>

<h3 id="why-do-i-use-it">Why do I use it?</h3>

<p><strong>import</strong> is used to specify the location and usage external libraries. You specify libraries that you want to use in conjunction with your Inkling code.</p>

<h3 id="how-do-i-use-it">How do I use it?</h3>

<p>Select the Inkling tab to view two generic import statements.</p>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">from</span> <span class="nx">libraryName</span> <span class="k">import</span> <span class="nx">importName1</span>
<span class="k">import</span> <span class="nx">importName2</span>
</code></pre>
<h2 id="import-example">Import Example</h2>

<p>Select the Inkling tab to view the example of an imported function.</p>
<pre class="highlight inkling tab-inkling--code"><code><span class="k">from</span> <span class="nx">utils</span> <span class="k">import</span> <span class="nx">split</span>

  <span class="k">datastore</span> <span class="nx">MNIST_data</span><span class="p">(</span><span class="nx">MNIST_training_data_schema</span><span class="p">)</span>
  <span class="k">copy</span> <span class="nx">mnist</span><span class="o">-</span><span class="nx">training</span><span class="p">.</span><span class="nx">csv</span> <span class="k">into</span> <span class="nx">MNIST_data</span> <span class="k">with</span> <span class="k">format</span><span class="o">=</span><span class="p">'</span><span class="nx">csv</span><span class="p">'</span>

<span class="c1"># prepare the data with imported function split</span>

<span class="nx">training_data</span><span class="p">,</span> <span class="nx">test_data</span> <span class="o">=</span> <span class="nx">split</span><span class="p">(</span><span class="nx">MNIST_data</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="nx">shuffle</span><span class="o">=</span><span class="nx">True</span><span class="p">)</span>
</code></pre>
      </div>
      <div class="dark-box">
          <div class="lang-selector">
                <a href="#" data-language-name="inkling--code">Inkling</a>
                <a href="#" data-language-name="inkling--syntax">Syntax</a>
          </div>
      </div>
    </div>

    </div>

  </div>
  <!-- at the end of the BODY -->
  <script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script>
  <script type="text/javascript"> docsearch({
  apiKey: '49fa6f01d7ff94a85b9b7434b1c2b7cf',
  indexName: 'bon-sai',
  inputSelector: '#docs-search',
  debug: false // Set debug to true if you want to inspect the dropdown
  });
  </script>
  </body>
</html>
