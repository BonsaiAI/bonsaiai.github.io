[//]: # (This is a fragment file which lives in the source folder of libbonsai and then gets compiled with the Slate framework into docs.bons.ai. DO NOT edit this file outside of Phabricator.)

# Simulator Class

[//]: # (This was taken from the README.md file to illustrate what this class should look like in Slate markdown. Reference http://docs.bons.ai/references/library-reference.html#simulator-class for what the current simulator class looks like.)

```
while(run()):
 episode_start()
  simulate()
  simulate()
  ...
 episode_start()
  simulate()
  simulate() -> terminal==true
 episode_start()
  simulate()
  ...
  etc
```

This class is used to interface with the server while training or running predictions against a **BRAIN**. It is an abstract base class, and by itself it does nothing.

The `Simulator` class has a close relationship with the **Inkling** file associated with the **BRAIN**. The name used to construct the `Simulator` must match the name of the simulator in the *Inkling* file.

There are two main methods one must override, `episode_start` and `simulate`. The lifecycle of a simulation is shown in code.


## episode_start()

> Example Inkling:

```inkling
schema Config
  UInt8 start_angle
end

schema State
    Float32 angle,
    Float32 velocity
end
```

> Example code:

```python
def episode_start(self, params):
  print(self.objective_name)
  self.angle = params.start_angle
  initial = {
    "angle": self.angle,
    "velocity": self.velocity,
  }
  return initial
```

```cpp
void Example::episode_start(const InklingMessage& params, InklingMessage& initial_state) {
    cout << objective_name() << endl;
    angle = params.get_float32("start_angle");
    initial_state.set_float32("velocity", velocity);
    initial_state.set_float32("angle",    angle);
}
```

This callback passes in a set of initial parameters and expects an initial state in return for the simulator. Before this callback is called, the property `objective_name` will be updated to reflect the current objective for this episode.

This call is where a simulation should be reset for the next round.

## simulate()

> Example Inkling:

```inkling
schema Action
    Int8{0, 1} delta
end
```

> Example code:

```python
def simulate(self, action):
  velocity = velocity - action.delta;
  terminal = (velocity <= 0.0)
  reward = reward_for_objective(self.objective_name)
  state = {
    "velocity": self.velocity,
    "angle": self.angle,
  }
  return (state, reward, terminal)
```

```cpp
void Test::simulate(const InklingMessage& action,
    InklingMessage& state, float& reward, bool& terminal) {
    velocity = velocity - action.get_int8("delta");
    terminal = (velocity <= 0.0);
    reward = reward_for_objective(objective_name());
    state.set_float32("velocity", velocity);
    state.set_float32("angle",    angle);
}
```

This callback is used to step the simulation forward by a single step. It passes in the `action` to be taken, and expects the resulting `state`, `reward` for the current `objective`, and a `terminal` flag used to signal the end of an episode. Note that an episode may be reset prematurely by the backend during training.

For multi-lesson curriculum the `objective_name` will change from episode to episode. The simulator should take care to insure that it is returning the correct reward for the different lessons.

Returning `true` for the `terminal` flag will signal the start of a new episode.





# Doxygen Simulator Class

[//]: # (This is the Doxygen output for the Simulator class. Make sure that everything below is represented above. Ignore all links for now, ideally they would be changed to anchor links within Slate but for now this document only captures the Simulator class.)

An abstract base class for creating simple simulations to run against a brain. The developer must implement the simulate method.

#### `public  `[`Simulator`](#classbonsai_1_1_simulator_1acbb6d3fa870ea90796d3151d3f7f672e)`(shared_ptr< `[`Brain`](#classbonsai_1_1_brain)` > brain,string name)` 

#### `public  `[`Simulator`](#classbonsai_1_1_simulator_1ac198e830563bc7a84538346957af4140)`(const `[`Simulator`](#classbonsai_1_1_simulator)` & rh)` 

#### `public virtual  `[`~Simulator`](#classbonsai_1_1_simulator_1a3fbc77a81d8a949b9f68009fde5236eb)`()` 

#### `public shared_ptr< `[`Brain`](#classbonsai_1_1_brain)` > `[`brain`](#classbonsai_1_1_simulator_1a2f667dac361f1d0f7212fa9d6226e954)`()` 

Returns the brain being used for this simulation

#### `public const shared_ptr< `[`Brain`](#classbonsai_1_1_brain)` > `[`brain`](#classbonsai_1_1_simulator_1a6174bb666955b4b4ac66ec69a597161b)`() const` 

#### `public const string & `[`name`](#classbonsai_1_1_simulator_1a5f8a300cf271f36a8208a73c76c46a16)`() const` 

Returns the simulator name that was passed in when contructed

#### `public bool `[`predict`](#classbonsai_1_1_simulator_1a12b841f50b017394d2531647cade6a7c)`() const` 

Returns weather or not the simulation is setup to run in predict or training mode

#### `public bool `[`run`](#classbonsai_1_1_simulator_1ac10c05bc1a32fdb44b7f10e352983d62)`()` 

Main loop call for driving the simulation. Will return false when the simulation has finished or halted.

The client should call this method in a loop until it returns false. To run for prediction `[brain()](#classbonsai_1_1_simulator_1a2f667dac361f1d0f7212fa9d6226e954)->config()->[predict()](#classbonsai_1_1_simulator_1a12b841f50b017394d2531647cade6a7c)` must return true.

```cpp
while( mysim.run() ){
    // no-op
}
```

[run()](#classbonsai_1_1_simulator_1ac10c05bc1a32fdb44b7f10e352983d62) will check the state of the server connection and call the appropriate virtual method below.

##### `public void `[`episode_start`](#classbonsai_1_1_simulator_1ab6bd5012aeba3fc44ad2abf9ab6bd517)`(const `[`InklingMessage`](#classbonsai_1_1_inkling_message)` & parameters,`[`InklingMessage`](#classbonsai_1_1_inkling_message)` & initial_state)` 

Subclassers should implement this method to handle the start of a simulation session.

parameters will be populated if a training session is running.

### Parameters
* `parameters` [InklingMessage](#classbonsai_1_1_inkling_message) of initialization parameters for an episode as defined in inkling. 

* `initial_state` Output [InklingMessage](#classbonsai_1_1_inkling_message). The subclasser should populate this message with the initial state of the simulation.

#### `public void `[`simulate`](#classbonsai_1_1_simulator_1afcc8abc450dabf64ced8c4adf282f94b)`(const `[`InklingMessage`](#classbonsai_1_1_inkling_message)` & action,`[`InklingMessage`](#classbonsai_1_1_inkling_message)` & state,float & reward,bool & terminal)` 

Subclassers should implement this method to advance a single step in a simulation.

### Parameters
* `action` Input [InklingMessage](#classbonsai_1_1_inkling_message) of action to be taken as defined in inkling. 

* `state` Output [InklingMessage](#classbonsai_1_1_inkling_message). Should be populated with the current simulator state. 

* `reward` Output reward value as calculated based upon the objective. 

* `terminal` Output terminal state. Set to true if the simulator is in a terminal state.

#### `public inline virtual bool `[`standby`](#classbonsai_1_1_simulator_1a07782c9bdab2303899ca8c6aa42335fc)`(const string & reason)` 

Subclassers can implement this method to take action when the server is busy.

The default action is to wait one second and continue. If returns `true`, the server status will be checked again and the loop will continue.